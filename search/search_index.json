{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to Radio Astronomy Playground","text":"<p>Radio Astronomy Playground is a learning and experimentation environment for understanding radio interferometry, calibration, imaging, and self-calibration. It is motivated by the difficulty of developing intuition for these workflows, which often involve many interacting parameters and iterative decisions. It includes:</p> <ul> <li>\u2728 Starbox \u2014 a Python package that serves as the core library for all   experiments and visualisations. It provides simple implementations of key   radio astronomy concepts (e.g. sky models, interferometers, visibility   prediction, calibration loops).</li> <li>\ud83d\udcda Interactive experiments \u2014 notebooks and dashboards that allow you to    explore how calibration and imaging behaviour changes as parameters,    assumptions, and models vary.</li> </ul> <p>This project is designed for learning, not as a replacement for production pipelines.</p>"},{"location":"#for-learners-and-users","title":"For learners and users","text":"<p>Explore the user documentation if you want to run experiments and build intuition for radio astronomy concepts through hands-on exploration:</p> <ul> <li>Tutorials \u2014 guided, step-by-step introductions</li> <li>How-to guides \u2014 workflows for specific tasks</li> <li>Explanations \u2014 conceptual background information</li> <li>Reference \u2014 API documentation</li> </ul>"},{"location":"#for-contributors-and-collaborators","title":"For contributors and collaborators","text":"<p>Explore the design documentation if you are interested in contributing, extending, or understanding the design of the project:</p> <ul> <li>Design \u2013 architectural decisions, domain exploration,   and prioritisation artefacts (including impact maps and ADRs).</li> </ul>"},{"location":"#project-scope-and-philosophy","title":"Project scope and philosophy","text":"<p>Radio Astronomy Playground focuses on:</p> <ul> <li>Optimising for insight rather than performance or scalability</li> <li>Interactive experiments and diagnostics over automated pipelines</li> <li>Failure modes as well as successful outcomes</li> <li>Clean, readable code and smooth user experience as enablers of learning</li> </ul> <p>Many features are intentionally simplified to keep behaviour visible and interpretable.</p> <p>The project is under active development. Interfaces, experiments, and documentation will evolve as understanding improves.</p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:docs","title":"docs","text":"<ul> <li>            ADR-001: Use Architectural Decision Records          </li> </ul>"},{"location":"tags/#tag:packaging","title":"packaging","text":"<ul> <li>            ADR-002: Manage dependencies with uv          </li> </ul>"},{"location":"design/","title":"Design Documentation","text":"<p>This section contains design documentation and artefacts. These are intended for contributors and maintainers rather than end users.</p> <ul> <li>\ud83d\udca1 Domain: the ubiquitous language and domain model documenting the key radio astronomy concepts used in this project</li> <li>\ud83c\udfdb\ufe0f Architecture: architectural decisions for the project.</li> <li>\ud83d\udd2e Vision: plans for the project.</li> <li>\ud83d\ude80 Requirements: functional and non-functional requirements for each deliverable slice.</li> </ul>"},{"location":"design/architecture/","title":"Architecture","text":"<p>Radio Astronomy Playground uses architectural decision records (ADRs) to ensure contributors can find the rationale for design choices that have a significant impact on one or more architecture qualities. Read more about the decision to use ADRs in ADR-001.</p> <ul> <li>Architectural Decision Records (ADRs)</li> <li>C4 diagrams</li> </ul>"},{"location":"design/architecture/c4-diagrams/","title":"C4 diagrams for Radio Astronomy Playground","text":""},{"location":"design/architecture/c4-diagrams/#system-context","title":"System Context","text":"<pre><code>C4Context\n    title System Context diagram for Radio Astronomy Playground\n    System_Boundary(b0, \"Learning Environment\", \"Environment\") {\n        Person(user, \"Radio Astronomy Learner\", \"A person that wants to run experiments.\")\n        System(SystemAA, \"Radio Astronomy Playground\", \"Allows a person to learn radio astronomy concepts through interactive experiments.\")\n    }\n    Rel(user, SystemAA, \"Uses\")\n</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"design/architecture/c4-diagrams/#container","title":"Container","text":"<pre><code>C4Container\ntitle Container diagram for Radio Astronomy Playground\n\nPerson(user, \"Radio Astronomy Learner\", \"A person that wants to run experiments.\")\n\nContainer_Boundary(c1, \"Radio Astronomy Playground\") {\n    Container(notebooks, \"Interactive notebooks\", \"Python, marimo\", \"A set of notebooks for running interactive experiments\")\n    Container(starbox, \"starbox\", \"Python package\", \"Provides all core functionality to a user\")\n    Container(filesystem, \"File System\", \"Local disk\", \"Stores experiment configuration files\")\n}\nRel(starbox, filesystem, \"Read/write\")\nRel(user, notebooks, \"Uses\", \"web browser\")\nRel(notebooks, starbox, \"Imports\", \"Python\")</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"design/architecture/c4-diagrams/#component-starbox","title":"Component - starbox","text":"<pre><code>C4Component\ntitle Component diagram for Radio Astronomy Playground - starbox\n\nContainer(notebooks, \"Interactive notebooks\", \"marimo\", \"A set of notebooks for running interactive experiments\")\nContainer(filesystem, \"File System\", \"Local disk\", \"Stores experiment configuration files\")\n\nContainer_Boundary(starbox, \"starbox\") {\n    Component(io, \"io\", \"Python module\", \"Functions to save and load experiment configuration files\")\n    Component(config, \"config\", \"Pydantic models\", \"Pydantic models defining experiment configuration\")\n\n    Component(telescope, \"Telescope\", \"Python class\", \"Simulates a radio interferometer\")\n    Component(skymodel, \"Sky Model\", \"Python class\", \"Simulates a model of radio sources in the sky\")\n    Component(observation, \"Observation\", \"Python class\", \"Simulates an observation\")\n    Component(corruptions, \"Corruptions\", \"Python class\", \"Simulates and applies corruptions to signal\")\n    Component(predict, \"Predict\", \"Python module\", \"Module with functions for predicting visibilities\")\n    Component(visibility_set, \"VisibilitySet\", \"Python class\", \"Stores visibilities and associated data\")\n\n    Component(solutions, \"Solutions\", \"Python class\", \"Stores and applies calibration solutions\")\n    Component(solver, \"Solver\", \"Python class\", \"Solves for calibration solutions\")\n    Component(imager, \"Imager\", \"Python class\", \"Grids visibilities and performs iFFT to produce images\")\n    Component(image, \"Image\", \"Numpy array\", \"Radio brightness of the sky\")\n    Component(viz, \"viz\", \"Python module\", \"Module with functions to generate plots\")\n\n    Rel(solver, visibility_set, \"Uses\")\n    Rel(solver, solutions, \"Returns\")\n\n    Rel(corruptions, visibility_set, \"Returns\")\n    Rel(corruptions, visibility_set, \"Uses\")\n    Rel(predict, visibility_set, \"Returns\")\n    Rel(predict, skymodel, \"Uses\")\n    Rel(predict, telescope, \"Uses\")\n    Rel(predict, observation, \"Uses\")\n    Rel(imager, visibility_set, \"Uses\")\n    Rel(imager, image, \"Returns\")\n    Rel(solutions, visibility_set, \"Returns\")\n\n    Rel(viz, solutions, \"Plots\")\n    Rel(viz, image, \"Plots\")\n\n}\nRel(notebooks, config, \"User inputs\")\nRel(config, telescope, \"Configures\")\nRel(config, observation, \"Configures\")\nRel(config, skymodel, \"Configures\")\nRel(config, corruptions, \"Configures\")\nRel(io, config, \"Uses\")\nRel(io, filesystem, \"Writes to\")</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"design/architecture/c4-diagrams/#component-notebooks","title":"Component - notebooks","text":"<pre><code>C4Component\ntitle Component diagram for Radio Astronomy Playground - notebooks\nContainer(starbox, \"starbox\", \"Python package\", \"Provides all core functionality to a user\")\nContainer(filesystem, \"File System\", \"Local disk\", \"Stores experiment configuration files\")\n\nContainer_Boundary(notebooks, \"notebooks\") {\n    Component(sliders, \"Interactive sliders\", \"Marimo\", \"Sliders for a user to experiment with configuration\")\n    Component(savebutton, \"Save button\", \"Marimo\", \"Saves an experiment configuration to file\")\n    Component(filebrowser, \"File browser\", \"Marimo\", \"Loads an experiment configuration from file\")\n    Component(experiment, \"Code cells\", \"Python\", \"Contains commands to run an experiment\")\n    Component(plots, \"Interactive plots\", \"Plotly\", \"Visualises the results of an experiment\")\n\n    Rel(experiment, sliders, \"Uses\")\n    Rel(savebutton, sliders, \"Uses\")\n    Rel(experiment, plots, \"Generates\")\n    Rel(experiment, filebrowser, \"Uses\")\n\n}\nRel(starbox, sliders, \"Uses\")\nRel(experiment, starbox, \"Uses\")\nRel(plots, starbox, \"Uses\")\nRel(filebrowser, filesystem, \"Loads from\")\nRel(savebutton, starbox, \"Uses\")</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"design/architecture/adr/","title":"Architectural Decision Records","text":"ADR Status Summary ADR-001: Use Architecture Decision Records \ud83d\udfe2 Accepted Use ADRs to explain the rationale behind architecturally significant design choices for future developers and AI assistants ADR-002: Manage dependencies with uv \ud83d\udfe2 Accepted Use uv to manage project dependencies"},{"location":"design/architecture/adr/001-use-architectural-decision-records/","title":"ADR-001: Use Architectural Decision Records","text":"Status \ud83d\udfe2 Accepted Created 2025-10-12 Last Updated 2025-10-12 Deciders Gemma Danks","tags":["docs"]},{"location":"design/architecture/adr/001-use-architectural-decision-records/#context","title":"Context","text":"<p>Architectural decisions are design choices that have a significant impact on one or more architecture qualities (e.g. modifiability, maintainability, observability, testability, scalability, interoperability, extensibility, portability). These decisions shape both the current state of a project and its long-term trajectory. Over time, the rationale for these decisions can get lost if they are not written down. One certainty in software development is that there will at some point be a need, or a desire, to change and adapt to new requirements, technologies and best practices.</p> <p>Without knowing why a decision was made, there is a risk that future developers will not feel empowered to make changes. This will lead to the accumulation of technical debt when working around the current architecture in the short-term and, in the long-term, will make the project obsolete. Conversely, there may be a very good reason for sticking to the original decision but if future developers are not aware of this reason they may make changes that must later be reverted, wasting time and effort. Nygard refers to these two alternatives as \"blind acceptance\" and \"blind reversal\" in a 2011 blog post on documenting architectural decisions, which we recommend reading for additional context.</p> <p>Another force to consider, at the time of writing in 2025, is the rapid adoption of AI tools for software development. A future developer may defer to an AI coding assistant or agent to recommend changes. Unless there is an AI-readable record of the rationale for earlier decisions, these tools are more likely to recommend reversing those they see as suboptimal. If this record exists, however, AI can be used more effectively to evolve a project and help onboard new developers (e.g. by providing summaries, answering questions and explaining the rationale behind certain choices).</p>","tags":["docs"]},{"location":"design/architecture/adr/001-use-architectural-decision-records/#problem-statement","title":"Problem Statement","text":"<p>How do we share the rationale for architectural decisions with future human or AI developers so that they can make more informed choices that ensure the continuity and evolvability of the project?</p>","tags":["docs"]},{"location":"design/architecture/adr/001-use-architectural-decision-records/#options-considered","title":"Options Considered","text":"Option Description Maintainability Knowledge Retention Traceability AI Usability Effort Discoverability Overall score Notes Weight - 1 2 1 1 1 1 - ADR Architectural Decision Record \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 21 Docs Architecture page in docs \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u2705 \u2705 20 README Architecture section in README \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u2705 \u26a0\ufe0f 19 Diagrams Flowcharts of decision trees \u26a0\ufe0f \u26a0\ufe0f \u274c \u274c \u26a0\ufe0f \u26a0\ufe0f 11 <p>\u2705 = 3 (good), \u26a0\ufe0f = 2 (acceptable), \u274c = 1 (poor)</p> <p>Maintaining a collection of Architectural Decision Records (ADRs) has been standard practice in industry, beginning the 1990s and popularised by Nygard's 2011 blog post. ADRs are small text files, written in Markdown, that describe the context, the decision, and the consequences of the decision (both good and bad). They ensures a detailed decision history that is human and AI-readable. Several templates for ADRs have been developed and are in use. These vary in the number of sections and level of detail and can be customised. They are easy to maintain and provide the best way to retain history of rationale for decisions but there is a larger effort involved in creating and reviewing them.</p> <p>Informal documentation in the project README or docs requires less effort and is easy to maintain but the history is mostly in the git commits and is harder to find and evaluate by humans. Using the documentation rather than the README makes the information more discoverable.</p> <p>Flowcharts provide a human-friendly visual overview but are more difficult to maintain and not as AI-friendly (although flowcharts as code is AI-friendly and might work well as a supplement if they are kept up-to-date).</p>","tags":["docs"]},{"location":"design/architecture/adr/001-use-architectural-decision-records/#decision-outcome","title":"Decision Outcome","text":"<p>We will keep a collection of Architectural Decision Records using a template based on MADR, which extends the template proposed by Nygard to include evaluating alternatives, which provides additional valuable knowledge to share with future developers and facilitates a re-evaluation at a later date.</p> <p>The title in the ADR file will use the pattern <code>ADR-NNN: &lt;Verb&gt; &lt;Object&gt; [optional qualifier]</code>, where NNN is a zero padded three digit number (e.g. ADR-001: Use Architectural Decision Records). ADRs will be numbered sequentially and monotonically. Numbers will not be reused.</p> <p>Metadata listed under the title will include: the status of the ADR (\ud83d\udfe1 Proposed, if not yet agreed upon and/or under review / \ud83d\udfe2 Accepted if agreed upon / \ud83d\udd35 Superseded by ADR-NNN if another decision reverses/replaces it), the date created, date last updated, a list of decision-makers and a list of tags.</p> <p>A Context section will describe the forces at play in value-neutral language, stating the facts on the background to a decision.</p> <p>A Problem Statement will summarise the challenge faced and, where possible, articulate it as a clear question to be answered.</p> <p>An Options Considered section will include a decision matrix scoring each of the options considered against the key drivers behind the decision. To avoid false precision, a simple scoring system will be used to rate an option as either good (\u2705), ok (\u26a0\ufe0f) or poor (\u274c). Emoticons will be used to provide human readers with a quick visual overview. These are also readable by current AI tools, such as ChatGPT, and keeping a legend with numerical scoring improves AI-readability. Optional weights will represent the relative importance of drivers and an overall score used to rank the options. A short description will supplement and summarise this decision matrix.</p> <p>The Decision Outcome section states the final decision and the justification based on the results of the decision matrix evaluation. It is stated in full sentences, with active voice.</p> <p>A Consequences section describes the resulting context, after applying the decision. This should describe both the positive and negative impacts of the decision on the project and should also list any unknowns or risks (and optionally what should be done to mitigate these risks).</p> <p>The whole document should be one or two pages long. We will write each ADR as if it is a conversation with a future developer and in a way that maximises its usefulness for AI assistants.</p> <p>We will keep ADRs in the project repository under <code>docs/architecture/adr/</code>. The filename will match the ADR title without the <code>ADR</code> prefix, all lowercase and <code>-</code> replacing spaces, e.g. <code>001-use-architectural-decision-records.md</code>. A template in this directory (<code>template.md</code>) will used for all new ADRs for consistency.</p> <p>If we change a decision at a later date, we will keep the old ADR but mark it as superseded. This way it is available for additional context.</p>","tags":["docs"]},{"location":"design/architecture/adr/001-use-architectural-decision-records/#consequences","title":"Consequences","text":"<p>Future developers will have clarity over why architecturally significant decisions were made and feel empowered to reverse these decisions as technologies and best practices evolve. AI assistants will gain the context needed to make better suggestions and recommendations. Developers will also benefit from using AI to summarise and explain earlier decisions. This will also be a powerful way to quickly onboard new developers, particularly as the collection of ADRs grows.</p> <p>There will be additional effort required for developers to create and review ADRs but this will pay off in the long-run by reducing the risk of wasting time and effort changing decisions that should not be changed or repeating mistakes that sharing more knowledge would have prevented. Effort can be reduced by using AI assistants to draft and review ADRs (this ADR and the template can be provided as context).</p>","tags":["docs"]},{"location":"design/architecture/adr/001-use-architectural-decision-records/#confirmation","title":"Confirmation","text":"<p>Developers will be prompted to confirm that they have checked for relevant ADRs when opening a PR. If they are making changes that includes a design choice they will be prompted to create a new ADR with status \"Proposed\", which must be reviewed and accepted before merging any code changes.</p>","tags":["docs"]},{"location":"design/architecture/adr/001-use-architectural-decision-records/#links","title":"Links","text":"Type Links ADRs Issues PRs","tags":["docs"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/","title":"ADR-002: Manage dependencies with uv","text":"Status \ud83d\udfe2 Accepted Created 2025-10-18 Last Updated 2025-10-18 Deciders Gemma Danks","tags":["packaging"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/#context","title":"Context","text":"<p>Every software project needs a way to manage dependencies. This allows reproducible, consistent installs across operating systems and machines. The Python ecosystem has several options that have evolved over time. It is important to choose a dependency manager that is fast, easy to use in CI, well supported by the community, uses metadata in the pyproject.toml file (i.e. PEP 621 compliant) and provides a good developer experience.</p>","tags":["packaging"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/#problem-statement","title":"Problem Statement","text":"<p>What dependency manager is best for our project?</p>","tags":["packaging"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/#options-considered","title":"Options Considered","text":"Option Description Developer Experience Speed Reproducibility Adoption CI PEP 621 Overall score Notes Weight - 2 2 2 1 1 1 - - uv New, fast replacement for multiple tools, built in Rust by creators of ruff. \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 \u2705 26 Very fast. Probably the future standard. Also manages python versions. Poetry Well established packaging manager with wide adoption. \u2705 \u26a0\ufe0f \u2705 \u2705 \u2705 \u2705 25 Mature, widely used but slower. PDM Light-weight, standards-compliant, written in Python. \u2705 \u26a0\ufe0f \u2705 \u26a0\ufe0f \u2705 \u2705 24 Good option, not as fast or popular as uv. mamba Reimplementation of conda in C++. \u26a0\ufe0f \u2705 \u2705 \u2705 \u2705 \u274c 23 Fast but not PEP 621 compliant conda Binary package manager, widely used for scientific software. \u26a0\ufe0f \u26a0\ufe0f \u2705 \u2705 \u2705 \u274c 21 Not as fast and not PEP 621 compliant pipenv Simplified packaging management tool. \u26a0\ufe0f \u26a0\ufe0f \u2705 \u26a0\ufe0f \u2705 \u274c 20 Not PEP 621 compliant. pip + venv Standard library tools. \u2705 \u26a0\ufe0f \u274c \u2705 \u2705 \u26a0\ufe0f 20 Not suitable for complex environments spack HPC-oriented packaging manager. Supports full stack. \u274c \u26a0\ufe0f \u2705 \u26a0\ufe0f \u26a0\ufe0f \u274c 17 Best for multi-language environments on HPC clusters. <p>\u2705 = 3 (good), \u26a0\ufe0f = 2 (acceptable), \u274c = 1 (poor)</p>","tags":["packaging"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/#decision-outcome","title":"Decision Outcome","text":"<p>We will use uv since it is extremely fast and likely to become the new standard. It provides a good developer experience and replaces multiple tools. Performance is particularly important for CI. Poetry and PDM are good alternatives. Poetry is more mature and widely adopted.</p>","tags":["packaging"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/#consequences","title":"Consequences","text":"<p>Using uv will simplify Python and dependency management. It is extremely fast and so will speed up continuous integration, reducing waiting time substantially where installing dependencies is the bottleneck. It also manages Python versions and is PEP 621 compliant. This tool is likely to become the new standard.</p> <p>A risk is that this is under active development and is not yet widely adopted. Alternatives to fall back on include Poetry or PDM. This ADR should be revisited in one year since development in this area is ongoing and adoption of particular tools is in a state of flux.</p>","tags":["packaging"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/#confirmation","title":"Confirmation","text":"<p>The project README will document the usage of uv. CI workflows will use uv and the uv.lock file will be placed under version control.</p>","tags":["packaging"]},{"location":"design/architecture/adr/002-manage-dependencies-with-uv/#links","title":"Links","text":"Type Links ADRs Issues PRs","tags":["packaging"]},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/","title":"ADR-003: Use Pydantic models for configuration schemas","text":"Status \ud83d\udfe2 Accepted Created 2026-01-31 Last Updated 2026-01-31 Deciders Gemma Danks"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#context","title":"Context","text":"<p>Configuration objects are used to define parameters for:</p> <ul> <li>Simulating data, such as sky models, array configurations, observations and corruptions.</li> <li>Processing data, such as calibration solver parameters and imaging parameters.</li> <li>Setting random seeds.</li> <li>Reproducing an experiment defined by the above.</li> </ul> <p>These configurations are:</p> <ul> <li>Edited interactively in notebooks and dashboards (via widgets or code cells)</li> <li>Saved and reloaded for reproducibility (in json format)</li> <li>Passed into classes to construct simulations</li> <li>Used in automated tests and CI fixtures</li> </ul> <p>The project prioritises:</p> <ul> <li>Reproducibility and provenance</li> <li>Inspectability and transparency</li> <li>Scientific validity</li> <li>Modularity between UI, configuration, and core domain logic</li> <li>Low friction for experimentation</li> </ul> <p>Configuration objects therefore need:</p> <ul> <li>Strong validation</li> <li>Clear schemas</li> <li>Easy serialisation/deserialisation</li> <li>Good ergonomics in notebooks</li> <li>Explicit constraints (e.g. positive counts, ranges)</li> </ul> <p>Multiple approaches were considered for representing configuration: plain dictionaries, dataclasses, and Pydantic models.</p>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#problem-statement","title":"Problem Statement","text":"<p>What representation should be used for configuration schemas (e.g. SkyModel, Telescope, Observation, Corruptions) to balance validation, reproducibility, usability, and modularity?</p>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#options-considered","title":"Options Considered","text":"<p>Decision drivers:</p> <ul> <li>Validation &amp; constraints \u2014 ability to express and enforce parameter bounds</li> <li>Reproducibility &amp; serialisation \u2014 easy save/load of configurations</li> <li>Developer experience \u2014 clarity in notebooks and code</li> <li>Modularity \u2014 clean separation between configuration and domain logic</li> <li>Maintenance effort \u2014 avoiding duplicated validation logic</li> </ul> Option Description Validation Reproducibility Developer Experience Modularity Maintenance Overall Notes Weight - 1 1 1 1 1 - - Plain dicts Use raw Python dictionaries \u274c \u26a0\ufe0f \u274c \u26a0\ufe0f \u274c Low No schema, no validation, fragile Dataclasses Use Python dataclasses for configs \u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f \u2705 \u26a0\ufe0f Medium Requires manual validation and serialization Pydantic models Use Pydantic BaseModel for configs \u2705 \u2705 \u2705 \u2705 \u2705 High Built-in validation, typing, and serialization <p>Legend: \u2705 = 3\u2003\u26a0\ufe0f = 2\u2003\u274c = 1</p>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#decision-outcome","title":"Decision Outcome","text":"<p>We will use Pydantic models as the canonical representation for configuration schemas.</p> <p>Pydantic provides:</p> <ul> <li>Declarative validation (e.g. bounds, required fields)</li> <li>Typed access to parameters</li> <li>Built-in serialisation (<code>model_dump</code>, <code>model_validate</code>)</li> <li>Clear schemas for documentation and UI generation</li> <li>Reduced duplicated validation logic compared to dataclasses and manual checks</li> </ul> <p>Domain objects (e.g. <code>SkyModel</code>, <code>Telescope</code>) will accept Pydantic config objects directly rather than raw dictionaries. <code>model_dump()</code> is only used at I/O boundaries (saving to disk, logging, transport).</p>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#consequences","title":"Consequences","text":""},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#good","title":"Good","text":"<ul> <li>Configuration constraints are explicit and enforced at construction time</li> <li>Experiments are easily serialised and replayed</li> <li>Notebook UX is improved through typed models</li> <li>Domain code avoids duplicated validation logic</li> <li>Clear separation between configuration (Pydantic) and behaviour (domain classes)</li> <li>Supports future pipeline use cases</li> </ul>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#bad","title":"Bad","text":"<ul> <li>Introduces Pydantic as a core dependency</li> <li>Slight learning curve for contributors unfamiliar with Pydantic</li> <li>Domain classes depend on an external library for configuration types</li> </ul>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#unknowns-risks","title":"Unknowns / Risks","text":"<ul> <li>Pydantic version changes may affect APIs</li> <li>Performance impact is negligible for MVP but may impact scaling later</li> <li>Tight coupling between config schemas and domain constructors</li> </ul>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#confirmation","title":"Confirmation","text":"<p>This ADR will be enforced by:</p> <ul> <li>Domain constructors accepting Pydantic config objects directly</li> <li>Avoiding <code>model_dump()</code> inside core logic (only at I/O boundaries)</li> <li>Code reviews checking for raw dict-based configs</li> <li>Documentation examples consistently using Pydantic models</li> <li>Tests using Pydantic fixtures for canonical configurations</li> </ul>"},{"location":"design/architecture/adr/003-use-pydantic-for-configuration-schemas/#links","title":"Links","text":"Type Links ADRs Issues https://github.com/gemmadanks/radio-astronomy-playground/issues/33 PRs https://github.com/gemmadanks/radio-astronomy-playground/pull/55"},{"location":"design/architecture/adr/template/","title":"ADR-NNN: short title for solved problem and found solution","text":"Status \ud83d\udfe1 Proposed / \ud83d\udfe2 Accepted / \ud83d\udd35 Superseded by ADR-NNN Created YYYY-MM-DD Last Updated YYYY-MM-DD Deciders Name"},{"location":"design/architecture/adr/template/#context","title":"Context","text":"<p>Describe the background and constraints written for future human and AI developers.</p>"},{"location":"design/architecture/adr/template/#problem-statement","title":"Problem Statement","text":"<p>Summarize the main challenge in one or two sentences. Then, phrase the decision explicitly as a question.</p>"},{"location":"design/architecture/adr/template/#options-considered","title":"Options Considered","text":"<p>Use the table below to evaluate your options against key decision drivers. 1.  Define your drivers \u2014 the forces, constraints, or architectural qualities that matter most (e.g. scalability, maintainability, observability, budget, effort). Add each driver as a column name. 2.  List your options \u2014 add each considered solution as a row. 3. (Optional) Assign weights to drivers to show relative importance. 4.  Describe each option \u2014 one line summary. 5.  Score each option for how well it satisfies each driver using the legend: \u2705 = 3 (Good)\u2003\u26a0\ufe0f = 2 (Acceptable)\u2003\u274c = 1 (Poor) 6.  Compute overall score: <pre><code>overall score = (Driver1 weight \u00d7 Driver1 score)\n              + (Driver2 weight \u00d7 Driver2 score)\n              + ...\n              + (DriverN weight \u00d7 DriverN score)\n</code></pre> 7. (Optional) Add short notes on the main pros and cons for each option. 8. (Optional) Sort the rows according to the overall score (best fit at the top)</p> Option Description Driver 1 Driver 2 Driver N Overall score Notes Weight - 1 1 1 - A B C <p>\u2705 = 3 (good), \u26a0\ufe0f = 2 (acceptable), \u274c = 1 (poor)</p>"},{"location":"design/architecture/adr/template/#decision-outcome","title":"Decision Outcome","text":"<p>We will use Option X because...</p> <p>Justify your choice using the results of the decision matrix above. Describe evidence to support the scoring.</p>"},{"location":"design/architecture/adr/template/#consequences","title":"Consequences","text":"<ul> <li>Good, because...</li> <li>Bad, because...</li> <li>Unknowns/risks</li> </ul>"},{"location":"design/architecture/adr/template/#confirmation","title":"Confirmation","text":"<p>How will you ensure this ADR is implemented and enforced?</p>"},{"location":"design/architecture/adr/template/#links","title":"Links","text":"Type Links ADRs Issues PRs"},{"location":"design/domain/","title":"Domain","text":"<p>Radio Astronomy Playground uses ideas from domain-driven design (DDD) to guide development and documentation. These include:</p>"},{"location":"design/domain/#ubiquitous-language","title":"\ud83d\udce1 Ubiquitous language","text":"<p>Building a ubiquitous language of radio astronomy terms that is reflected in the code, which makes it easier to communicate with domain experts and to learn radio astronomy through code-based experiments.</p>"},{"location":"design/domain/#domain-model","title":"\ud83e\udde9 Domain model","text":"<p>Designing the software around a domain model with context boundaries defined according to how radio astronomers typically process data from an observation.</p>"},{"location":"design/domain/#event-storming","title":"\u23f0 Event storming","text":"<p>Using an event-storming-inspired approach to explore and document radio astronomy workflows and interactive experiments.</p>"},{"location":"design/domain/aggregates/","title":"Domain model","text":"<p>This shows the core domain-driven-design (DDD) aggregates (groups of domain concepts treated as a unit) and domain services (performs domain operations) that are part of starbox.</p>"},{"location":"design/domain/aggregates/#aggregate-roots","title":"Aggregate roots","text":"<ul> <li>Telescope</li> <li>Observation</li> <li>SkyModel</li> </ul>"},{"location":"design/domain/aggregates/#aggregates","title":"Aggregates","text":"<ul> <li>Station (inside Telescope)</li> <li>AntennaElement (inside Station)</li> </ul>"},{"location":"design/domain/aggregates/#value-objects","title":"Value objects","text":"<ul> <li>Site</li> <li>CalibrationConfig</li> </ul>"},{"location":"design/domain/aggregates/#strategies","title":"Strategies","text":"<ul> <li>Corruption</li> <li>BeamModel</li> </ul>"},{"location":"design/domain/aggregates/#services","title":"Services","text":"<ul> <li>CalibrationSolver</li> <li>VisibilityPredictor</li> </ul>"},{"location":"design/domain/aggregates/#derived-artifacts","title":"Derived artifacts","text":"<ul> <li>VisibilitySet</li> <li>CalibrationSolution</li> </ul> <pre><code>classDiagram\n    Telescope *-- Station\n    Telescope --&gt; Site\n    Station *-- AntennaElement\n    Station --&gt; BeamModel\n\n    VisibilityPredictor ..&gt; Telescope\n    VisibilityPredictor ..&gt; Observation\n    VisibilityPredictor ..&gt; SkyModel\n\n    Corruption &lt;|-- StationGains\n    Corruption &lt;|-- ThermalNoise\n    Corruption &lt;|-- Bandpass\n    Corruption &lt;|-- PhaseScreen\n\n    CalibrationSolver ..&gt; VisibilitySet\n    CalibrationSolver ..&gt; CalibrationSolution\n    CalibrationSolver ..&gt; CalibrationConfig\n\n    class Telescope{\n        +string name\n        +Site location\n        +list~Station~ stations\n\n        +baseline_station_pairs()\n        +uvw(Observation)\n        +plot()\n        +hour_angle(Observation)\n    }\n\n    class Site{\n        +float latitude_rad\n        +float longitude_rad\n        +float height_m\n    }\n\n    class Station{\n      +string name\n      +float diameter_m\n      +tuple position_enu_m\n      +BeamModel beam_model\n      +list~AntennaElement~ antenna_elements\n      +plot()\n    }\n\n    class AntennaElement{\n      +tuple element_position_enu_m\n      +float element_rotation_angle\n    }\n\n    class SkyModel{\n        +string name\n        +tuple phase_centre_rad\n        +tuple fov_ra_dec_rad\n        +nd.array ra_rad\n        +nd.array dec_rad\n        +nd.array flux_jy\n        +nd.array alpha\n        +sample_sources(max_flux, num_sources)\n        +lmn(phase_centre_rad=None)\n        +plot()\n    }\n\n    class Observation{\n        +nd.array times_mjd\n        +nd.array freqs_hz\n        +tuple phase_centre_rad\n    }\n\n    class VisibilityPredictor{\n        +predict_visibilities(telescope, observation, skymodel) VisibilitySet\n    }\n\n    class VisibilitySet{\n        +nd.array visibilities\n        +nd.array uvw_m\n        +nd.array ant1\n        +nd.array ant2\n        +nd.array times_mjd\n        +nd.array time_index\n        +nd.array freqs_hz\n        +nd.array weights\n    }\n\n    class CalibrationConfig{\n        +string mode\n        +float solint_time\n        +float solint_freq\n        +string ref_ant\n        +float min_snr\n        +int min_nvis\n        +int max_iters\n        +float tol\n        +tuple clip_amp_range\n        +string normalisation_policy\n    }\n\n    class CalibrationSolver{\n        +solve(vis_obs, vis_model, calibration_config) CalibrationSolution\n    }\n\n    class CalibrationSolution{\n        +nd.array gains\n        +nd.array time_centres_mjd\n        +nd.array freq_centres_hz\n        +int ref_ant\n        +nd.array flags\n        +nd.array qa_metrics\n        +evaluate()\n        +apply(vis_obs) VisibilitySet\n    }\n\n    class BeamModel{\n        +string name\n        +voltage_response(l, m, freqs_hz, times_mjd)\n    }\n\n    class Corruption{\n        +string name\n        +bool enabled\n        +apply(vis, telescope, observation) VisibilitySet\n    }\n</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"design/domain/concepts/","title":"Key concepts","text":"<p>The following is a list of common terms used in the radio astronomy domain. Key concepts that form the ubiquitous language for starbox have links with further details. This is a living document and will be updated as code is added.</p>"},{"location":"design/domain/concepts/#observations","title":"Observations","text":"<ul> <li>Observation</li> <li>Scan: A contiguous time interval during which the telescope observes a single field with fixed pointing.</li> <li>Calibrator: A source observed primarily to estimate instrumental or propagation effects.</li> <li>Target: A source or field observed for scientific analysis.</li> </ul>"},{"location":"design/domain/concepts/#pointing","title":"Pointing","text":"<ul> <li>Pointing</li> <li>Right ascension</li> <li>Declination</li> <li>Hour angle</li> <li>Integration time</li> <li>Phase centre</li> </ul>"},{"location":"design/domain/concepts/#sky-and-signals","title":"Sky and signals","text":"<ul> <li>Polarization</li> <li>Faraday rotation</li> <li>RFI</li> <li>[Sources]: sources of radio emission in a sky model or image.<ul> <li>Point source</li> <li>Extended source (extended emission or gaussian blob)</li> </ul> </li> <li>Sky model (source catalog, source list)</li> <li>Apparent sky: The sky brightness distribution as modified by instrumental and propagation effects.</li> <li>True sky: The intrinsic sky brightness distribution, independent of the instrument.</li> <li>Patches: Groups of sky model components treated together, typically for direction-dependent calibration.</li> </ul>"},{"location":"design/domain/concepts/#modes","title":"Modes","text":"<ul> <li>Wideband</li> <li>Widefield</li> <li>Drift scan</li> </ul>"},{"location":"design/domain/concepts/#units-quantities","title":"Units &amp; quantities","text":"<ul> <li>Jansky</li> <li>Flux density (flux, intensity or brightness)</li> </ul>"},{"location":"design/domain/concepts/#coordinates-axes","title":"Coordinates &amp; axes","text":"<ul> <li>Direction cosines (l,m,n)</li> <li>Baseline coordinates (u,v,w)</li> </ul>"},{"location":"design/domain/concepts/#telescope","title":"Telescope","text":"<ul> <li>Telescope (interferometer, array, sub-array, station, sub-station)</li> <li>Antenna (receptor, receiver)</li> <li>Aperture</li> </ul>"},{"location":"design/domain/concepts/#array-configuration","title":"Array configuration","text":"<ul> <li>uv-coverage</li> <li>Baseline</li> <li>Rigid rotation</li> </ul>"},{"location":"design/domain/concepts/#interferometry","title":"Interferometry","text":"<ul> <li>VLBI</li> <li>Aperture synthesis</li> <li>Fringes</li> <li>Correlator</li> <li>Delay</li> </ul>"},{"location":"design/domain/concepts/#data-processing","title":"Data processing","text":""},{"location":"design/domain/concepts/#beam","title":"Beam","text":"<ul> <li>Beam model (primary beam)</li> <li>Beam forming</li> <li>Tied-array beam forming</li> <li>Side lobes</li> </ul>"},{"location":"design/domain/concepts/#calibration","title":"Calibration","text":"<ul> <li>Calibration solution (solution): An estimated set of parameters that can be applied to visibilities to correct for corruptions introduced by the hardware, electronics, atmosphere or thermal noise.</li> <li>Reference antenna: A station used to fix phase and amplitude degeneracies during calibration.</li> <li>Calibration: The process of estimating and applying calibration solutions.</li> <li>Jones matrix</li> <li>Solver: The algorithm used to estimate calibration solutions.</li> <li>Predict: The process of predicting ideal visibilities from sky model components.</li> <li>Self-calibration cycle: An iterative loop of imaging, model update, and calibration.</li> </ul>"},{"location":"design/domain/concepts/#modes_1","title":"Modes","text":"<ul> <li>Phase-only</li> <li>Amplitude and phase</li> <li>Direction-independent</li> <li>Direction-dependent</li> <li>Self-calibration (self-calibration cycle)</li> </ul>"},{"location":"design/domain/concepts/#gains","title":"Gains","text":"<ul> <li>Phase</li> <li>Amplitude</li> <li>Complex gains</li> </ul>"},{"location":"design/domain/concepts/#effects","title":"Effects","text":"<ul> <li>Corruptions<ul> <li>Phase screen (TEC screen)</li> <li>Bandpass</li> <li>Delay</li> <li>Direction-dependent effect (DDE)</li> </ul> </li> </ul>"},{"location":"design/domain/concepts/#control","title":"Control","text":"<ul> <li>Flagging</li> <li>Reference antenna</li> </ul>"},{"location":"design/domain/concepts/#imaging","title":"Imaging","text":"<ul> <li>Imaging</li> </ul>"},{"location":"design/domain/concepts/#modes_2","title":"Modes","text":"<ul> <li>Continuum imaging</li> <li>Spectral imaging</li> </ul>"},{"location":"design/domain/concepts/#data-products","title":"Data products","text":"<ul> <li>Artifacts</li> <li>Images<ul> <li>Dirty image</li> <li>Residual image</li> <li>Clean image (restored image)</li> <li>Model image</li> </ul> </li> <li>Image cube: one image per frequency channel stacked together.</li> <li>Spectral index map</li> </ul>"},{"location":"design/domain/concepts/#quality-metrics","title":"Quality Metrics","text":"<ul> <li>SNR</li> <li>Dynamic range</li> </ul>"},{"location":"design/domain/concepts/#wide-field","title":"Wide-field","text":"<ul> <li>Facet</li> <li>Sector</li> <li>Field</li> <li>W-term</li> </ul>"},{"location":"design/domain/concepts/#polarization","title":"Polarization","text":"<ul> <li>Stokes parameters (I, Q, U, V)</li> </ul>"},{"location":"design/domain/concepts/#deconvolution","title":"Deconvolution","text":"<ul> <li>Deconvolution</li> <li>Briggs weighting</li> <li>Model component (CLEAN component)</li> <li>Major cycle</li> <li>Minor cycle</li> <li>Point spread function (PSF)</li> <li>FWHM</li> <li>First null</li> </ul>"},{"location":"design/domain/concepts/#concepts","title":"Concepts","text":"<ul> <li>Image plane (image space, pixel space)</li> <li>Visibility plane (visibility space, Fourier space)</li> </ul>"},{"location":"design/domain/concepts/#data-formats","title":"Data formats","text":"<ul> <li>Measurement set</li> <li>FITS file</li> <li>CASA table</li> <li>h5parm</li> </ul>"},{"location":"design/domain/concepts/#algorithms","title":"Algorithms","text":"<ul> <li>W-stacking</li> <li>CLEAN</li> <li>H\u00f6gbom CLEAN</li> <li>Multi-scale CLEAN</li> <li>Radio Interferometry Measurement equation (RIME)</li> <li>Gridding</li> <li>Source finding</li> </ul>"},{"location":"design/domain/concepts/beam-model/","title":"Beam Model","text":"<p>A beam model describes the voltage response of a station as a function of direction, time and frequency. This response is due to the physical properties of the station. The beam model is used to account for beam effects when predicting visibilities.</p> <p>A beam model may optionally include pointing errors, which represent beam misplacement due to mechanical or electronic pointing offsets</p>"},{"location":"design/domain/concepts/beam-model/#role","title":"Role","text":"<p>The beam model is evaluated during prediction to weight sky components as a function of direction, time, and frequency in order to simulate realistic observed visibilities. These simulations can be used to experiment with different effects and for testing calibration workflows with increasingly difficult tasks.</p>"},{"location":"design/domain/concepts/beam-model/#invariants","title":"Invariants","text":"<ul> <li>Beam models are evaluated and applied to model components during predict</li> <li>A beam model is user-configurable to facilitate experimentation and learning</li> </ul>"},{"location":"design/domain/concepts/beam-model/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Sky Model</li> <li>Telescope</li> <li>Predict</li> <li>Corruptions</li> </ul>"},{"location":"design/domain/concepts/corruptions/","title":"Corruptions","text":"<p>Corruptions represent how the true signal from the sky is transformed into the observed signal. They account for the difference between ideal visibilities (i.e. visibilities predicted from a perfect sky model) and observed visibilities that are effects not explained by the sky model, beam model and array geometry. This includes effects originating from the telescope hardware (instrumental effects) as well as the propagation medium between the sources and the telescope (e.g. the atmosphere).</p> <p>Corruptions describe a set of transformations in visibility space in order to simulate different measurement effects. Corruptions are optionally applied in order of decreasing proximity to the sky model after predicting model visibilities.</p> <ol> <li>Phase screen: time- and baseline-dependent phase errors due to variations in the ionosphere, usually direction-dependent and can blur images if not corrected</li> <li>Delays / clocks: linear phase vs. frequency</li> <li>Bandpass: gains due to frequency-dependent effects on different channels</li> <li>Complex gains: per station time and frequency dependent variability in phase and amplitude, assumed to be constant over a calibration solution interval</li> <li>Thermal noise: additive random noise from receiver and sky, sets the sensitivity limit of an observation.</li> </ol> <p>Missing and flagged data can also be simulated.</p>"},{"location":"design/domain/concepts/corruptions/#role","title":"Role","text":"<p>Corruptions are applied to predicted model visibilities in order to simulate realistic observed visibilities. These simulations can be used to experiment with different effects and for testing calibration workflows with increasingly difficult tasks.</p>"},{"location":"design/domain/concepts/corruptions/#invariants","title":"Invariants","text":"<ul> <li>Corruptions are applied to visibilities after predict in order of decreasing proximity to the sky model: phase screen -&gt; delays -&gt; bandpass -&gt; complex gains -&gt; noise.</li> <li>Additive effects (noise) are always applied last.</li> <li>Random processes (e.g. noise) are reproducible for a given set of parameters and random seed</li> <li>Applying corruptions transforms visibilities to produce modified visibilities</li> <li>Corruptions are user-configurable to facilitate experimentation and learning</li> </ul>"},{"location":"design/domain/concepts/corruptions/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Sky Model</li> <li>Telescope</li> <li>Predict</li> <li>Beam Model</li> </ul>"},{"location":"design/domain/concepts/imaging/","title":"Imaging","text":"<p>Imaging is the process of transforming interferometric measurements of the sky from Fourier space (visibilities) into image space (pixels) in order to produce a visual representation of the sky brightness distribution.</p> <p>Imaging involves mapping irregularly sampled visibilities onto a regular grid in the uv-plane and forming an image via an inverse Fourier transform, which represents the sky convolved with the point-spread function (PSF) of the interferometer. Deconvolution techniques are typically used to estimate the underlying sky brightness distribution by accounting for the effects of incomplete uv-coverage.</p>"},{"location":"design/domain/concepts/imaging/#deconvolution","title":"Deconvolution","text":"<p>This step in imaging iteratively builds a sky model by identifying significant structure in the dirty image, subtracting the PSF response of that structure, and repeating until the residuals are consistent with noise.</p> <p>CLEAN is a class of algorithms (including H\u00f6gbom, Clark, Cotton-Schwab) that are used in deconvolution: deconvolution is often called \"CLEANing\"; model components identified during deconvolution are often called CLEAN components; and the final image is often called the CLEAN image.</p>"},{"location":"design/domain/concepts/imaging/#inputs","title":"Inputs","text":"<ul> <li>Visibilities (VisibilitySet): complex visibilities indexed by baseline, time, frequency and polarization</li> <li>UVW coordinates, weights, and flags (if present)</li> <li>Observation parameters: phase centre, frequency information, and time sampling</li> <li>Imaging configuration:<ul> <li>Image parameters (image size, pixel size/cell size, field of view)</li> <li>Gridding configuration (kernel, oversampling/support, w-term handling)</li> <li>Weighting scheme (natural / uniform / robust)</li> <li>Deconvolution settings (algorithm choice, stopping criteria, masks)</li> </ul> </li> </ul>"},{"location":"design/domain/concepts/imaging/#outputs","title":"Outputs","text":"<p>Imaging produces one or more image products, including:</p> <ul> <li>Dirty image: the direct inverse transform of gridded visibilities.</li> <li>PSF (dirty beam): the image-plane response of the sampling pattern and weighting.</li> <li>Model image: a deconvolved estimate of the sky brightness.</li> <li>Residual image: dirty image minus the model convolved with the PSF.</li> <li>Restored image: model image convolved with a restoring beam plus residuals.</li> </ul> <p>These may be produced as 2D images or image cubes (i.e. an image per frequency channel).</p>"},{"location":"design/domain/concepts/imaging/#role","title":"Role","text":"<ul> <li>Visualise the effect of array layout, observation parameters, measurement effects.</li> <li>Producing improved sky models during iterative self-calibration.</li> <li>Experiment with (and optimise) imaging and gridding settings and algorithms.</li> <li>Provide data for quality assurance and diagnostics that reveal sampling limitations and calibration errors.</li> </ul>"},{"location":"design/domain/concepts/imaging/#invariants","title":"Invariants","text":"<ul> <li>Imaging products are defined relative to a specific phase centre and image coordinate system.</li> <li>Image products share a common image grid (pixel size, shape, coordinate definition).</li> <li>The PSF corresponds to the same weighting and gridding choices used to form the dirty image.</li> <li>Residuals are computed by subtracting the model image convolved with the PSF from the dirty image.</li> <li>Imaging does not modify input visibilities.</li> </ul>"},{"location":"design/domain/concepts/imaging/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Sky Model</li> <li>Telescope</li> <li>Predict</li> <li>Corruptions</li> </ul>"},{"location":"design/domain/concepts/observation/","title":"Observation","text":"<p>An observation describes how a telescope measures radio emissions in the sky.</p>"},{"location":"design/domain/concepts/observation/#representations","title":"Representations","text":"<ul> <li>A single phase centre is given as RA and Dec in radians</li> <li>Times are given as central, evenly spaced, integration times in MJD</li> <li>Frequencies are given as central frequencies of each channel</li> <li>Each channel has the same channel bandwidth given in Hz</li> </ul>"},{"location":"design/domain/concepts/observation/#role","title":"Role","text":"<ul> <li>Used together with the geometry data from the telescope to compute baseline coordinates (UVW) as the Earth rotates</li> <li>Specifies times and frequencies for predicting ideal visibilities from a sky model</li> <li>Determines the minimum frequency and time intervals for downstream averaging and calibration solution intervals</li> </ul>"},{"location":"design/domain/concepts/observation/#invariants","title":"Invariants","text":"<ul> <li>Observation parameters are independent of telescope geometry</li> <li>A single observation has a single phase centre</li> <li>Times are increasing and spaced by the same integration time</li> <li>Pointing errors are modeled in the measurement model, not as part of an observation</li> </ul>"},{"location":"design/domain/concepts/observation/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Sky Model</li> <li>Telescope</li> <li>Predict</li> </ul>"},{"location":"design/domain/concepts/predict/","title":"Predict","text":"<p>Predict refers to the process of computing ideal interferometric visibilities from a sky model using a specific configuration of an interferometer and observation. It is used to \"predict\" what an interferometer would measure, under these conditions in the absence of corruptions (e.g. instrumental or atmospheric effects) and is usually done with high time and frequency resolution.</p>"},{"location":"design/domain/concepts/predict/#inputs","title":"Inputs","text":"<ul> <li>A sky model (locations and fluxes of radio sources in the sky)</li> <li>Array geometry (station positions and derived baselines)</li> <li>Observation parameters (frequency and time intervals, phase centre)</li> </ul>"},{"location":"design/domain/concepts/predict/#outputs","title":"Outputs","text":"<ul> <li>A set of complex visibilities per baseline, time, freq, polarization.</li> </ul>"},{"location":"design/domain/concepts/predict/#role","title":"Role","text":"<p>Predict is essential for several workflows that require ideal visibilities to be computed. These include: - Synthetic visibilities for simulations and tests. These may have corruptions applied after prediction. - Model visibilities for calibrating observed visibilities. - Model visibilities that are subtracted from observed visibilities to generate residual visibilities during self-calibration.</p>"},{"location":"design/domain/concepts/predict/#invariants","title":"Invariants","text":"<ul> <li>Predict does not introduce corruptions</li> <li>Corruptions are applied after predict</li> <li>Averaging is performed after predict</li> <li>Predict is deterministic</li> <li>Predict is defined relative to a specific phase centre and coordinate frame</li> </ul>"},{"location":"design/domain/concepts/predict/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Sky Model</li> <li>Telescope</li> <li>Beam Model</li> </ul>"},{"location":"design/domain/concepts/sky-model/","title":"Sky model","text":"<p>A sky model is a representation of the positions, shapes, and brightness of radio-emitting sources on the sky, including their frequency-dependence.</p> <p>Each source or component may include:</p> <ul> <li>Position in right ascension (RA) and declination (Dec) in degrees, radians or sexagesimal hours, minutes and seconds.</li> <li>Brightness (flux density) in Jansky for one or more Stokes parameters (I, Q, U, V).</li> <li>Shape (for extended sources) specified as:<ul> <li>Width along major (longest) and minor (shortest) axes at full width half maximum (FWHM) in arcseconds</li> <li>Orientation of the major axis in degrees eastward from North</li> </ul> </li> <li>Spectral index at a reference frequency (dimensionless), indicating whether the emission is synchrotron (negative) or thermal (positive).</li> <li>Optionally, an association with a patch, representing a cluster of sources treated together (e.g. for direction-dependent calibration).</li> </ul>"},{"location":"design/domain/concepts/sky-model/#representations","title":"Representations","text":"<ul> <li>An image or image cube (pixel-based model).</li> <li>A list or source catalog.</li> </ul>"},{"location":"design/domain/concepts/sky-model/#role","title":"Role","text":"<p>A sky model represents an estimate of the true sky. It can be an existing model extracted from a sky survey database or an output of the image cleaning or source-finding process. It is used to:</p> <ul> <li>Predict model visibilities for calibrating observed visibilities to remove corruptions.</li> <li>Iteratively improve images produced via self-calibration.</li> </ul>"},{"location":"design/domain/concepts/sky-model/#invariants","title":"Invariants","text":"<ul> <li>A sky model is defined with respect to a specific phase centre, coordinate frame and field of view.</li> <li>Flux densities are expressed per Stokes parameter.</li> <li>A sky model is valid only over the time and frequency range for which it was derived.</li> <li>Each source belongs to at most one patch within a given sky model.</li> </ul>"},{"location":"design/domain/concepts/sky-model/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Predict</li> <li>Beam Model</li> </ul>"},{"location":"design/domain/concepts/telescope/","title":"Telescope","text":"<p>A telescope is the term used to collectively describe one or more stations (dish or array of antennas), each of which can be \"pointed\" (digitally or physically) along a line of sight given by specifying a phase centre (location on the sky). When there is more than one station the telescope functions as an interferometer. Each station forms a beam on the sky. A pair of stations forms a baseline and their signals are inputs to a correlator which outputs visibilities. The layout of stations determines how signals from the sky are sampled as Earth rotates.</p>"},{"location":"design/domain/concepts/telescope/#role","title":"Role","text":"<p>The geometric properties of a telescope, together with the parameters of an observation, define: - Baselines used when predicting visibilities - UV-coverage to evaluate how the signals from the sky are sampled - Parameters to tweak for simulating the effects of telescope geometry on data products</p>"},{"location":"design/domain/concepts/telescope/#invariants","title":"Invariants","text":"<ul> <li>Station IDs are unique for a given telescope</li> <li>The centre of each station has a position relative to the telescope site and is given as East (m), North (m) and up (m) coordinates.</li> <li>The location of the centre of a telescope (\"site\") is given in longitude (deg), latitude (deg) and height (m).</li> <li>Beams are formed at the station level.</li> <li>Telescope geometry is fixed over a given observation</li> <li>Each antenna element belongs to a single station</li> </ul>"},{"location":"design/domain/concepts/telescope/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Sky Model</li> <li>Predict</li> <li>Observation</li> </ul>"},{"location":"design/domain/concepts/template/","title":"Concept Name","text":"<p>Short introduction.</p>"},{"location":"design/domain/concepts/template/#representations","title":"Representations","text":"<p>How is this represented (data format etc.)</p>"},{"location":"design/domain/concepts/template/#role","title":"Role","text":"<p>What is this used for?</p>"},{"location":"design/domain/concepts/template/#invariants","title":"Invariants","text":"<p>Rules that always apply for this concept.</p>"},{"location":"design/domain/concepts/template/#related-concepts","title":"Related concepts","text":"<p>Links to other concepts.</p>"},{"location":"design/domain/concepts/visibility-set/","title":"Visibility Set","text":"<p>A VisibilitySet represents a collection of interferometric measurements produced by correlating signals from pairs of stations (baselines). Each visibility represents the spatial coherence of the sky at a specific baseline, time, polarization and frequency.</p>"},{"location":"design/domain/concepts/visibility-set/#representations","title":"Representations","text":"<ul> <li>An array of complex values (representing amplitude and phase) indexed by baseline, time, frequency, and polarization.</li> <li>UVW baseline coordinates (m) derived from telescope and observation parameters</li> <li>Optional weights and flags per visibility.</li> </ul>"},{"location":"design/domain/concepts/visibility-set/#role","title":"Role","text":"<p>Inputs and outputs for: - Calibration (model visibilities are compared to observed visibilities) - Applying corruptions or beam effects (measurement model) - Subtraction (model visibilities from residual visibilities) during a major cycle in CLEAN-like deconvolution algorithms - Averaging over time and/or frequency</p> <p>Inputs for: - Gridding (visibilities are mapped to a grid in a 2D uv-plane)</p>"},{"location":"design/domain/concepts/visibility-set/#invariants","title":"Invariants","text":"<ul> <li>UVW coordinates are defined relative to the observation phase centre.</li> <li>All per-visibility arrays within a VisibilitySet are aligned: the same index refers to the same baseline, time, frequency, and polarization across all fields.</li> <li>Time and frequency axes are ordered.</li> <li>Averaging produces a new effective sampling (time/frequency centres and widths).</li> <li>Transformations produce new visibility sets rather than modifying the conceptual meaning of the original.</li> </ul>"},{"location":"design/domain/concepts/visibility-set/#related-concepts","title":"Related concepts","text":"<ul> <li>Imaging</li> <li>Sky Model</li> <li>Telescope</li> <li>Observation</li> </ul>"},{"location":"design/domain/event-storming/","title":"Event storming","text":"<p>Interactive experiment</p>"},{"location":"design/domain/event-storming/interactive-experiment/","title":"Interactive Experiment","text":""},{"location":"design/domain/event-storming/interactive-experiment/#scenario","title":"Scenario","text":"<p>A user interactively modifies station layout, observation parameters, and instrument models and immediately sees how the final image products change. The primary goal is conceptual exploration and algorithm intuition, not production-scale processing.</p>"},{"location":"design/domain/event-storming/interactive-experiment/#scope","title":"Scope","text":"<ul> <li>Simulation-based</li> <li>Small datasets</li> <li>Fast feedback (seconds, not minutes)</li> <li>Panel app with sliders, toggles, and dropdown widgets</li> </ul> <p>Out of scope:</p> <ul> <li>Calibration (including self-calibration)</li> <li>Large datasets</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#layered-event-storming-view","title":"Layered Event Storming View","text":"<p>This workflow has three layers:</p> <ol> <li>Commands (user intent)</li> <li>Domain events (facts that happened)</li> <li>Views (what is displayed)</li> </ol>"},{"location":"design/domain/event-storming/interactive-experiment/#1-commands-user-intent","title":"1. Commands (User Intent)","text":"<p>These map to notebook widgets.</p>"},{"location":"design/domain/event-storming/interactive-experiment/#array-configuration","title":"Array configuration","text":"<ul> <li>Select array layout (example or custom)</li> <li>Add station</li> <li>Remove station</li> <li>Modify station positions</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#observation-setup","title":"Observation setup","text":"<ul> <li>Set integration time</li> <li>Set total observation duration</li> <li>Set frequency setup</li> <li>Set phase center</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#sky-instrument","title":"Sky &amp; instrument","text":"<ul> <li>Select sky model</li> <li>Select primary beam model</li> <li>Enable / disable corruption models</li> <li>Set noise level</li> <li>Set gain / phase error parameters</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#imaging","title":"Imaging","text":"<ul> <li>Select weighting scheme (natural / uniform / robust)</li> <li>Set image size and cell size</li> <li>Set deconvolution parameters</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#2-domain-events-what-happens","title":"2. Domain Events (What Happens)","text":""},{"location":"design/domain/event-storming/interactive-experiment/#configuration","title":"Configuration","text":"<ul> <li>Site location specified</li> <li>Array configuration defined</li> <li>Observation setup defined</li> <li>Sky model selected</li> <li>Instrument model defined</li> <li>Primary beam model selected</li> <li>Visibility averaging policy defined</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#simulation","title":"Simulation","text":"<ul> <li>UVW sampling computed</li> <li>Sky model visibilities predicted</li> <li>Instrument corruptions applied</li> <li>Visibilities averaged</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#imaging_1","title":"Imaging","text":"<ul> <li>Visibilities gridded</li> <li>Dirty image generated</li> <li>PSF generated</li> <li>Deconvolution performed</li> <li>Model image generated</li> <li>Residual image generated</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#iteration","title":"Iteration","text":"<ul> <li>Parameters updated</li> <li>Affected intermediate products invalidated</li> <li>Required products recomputed</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#3-views-projections","title":"3. Views (Projections)","text":"<p>These are derived, read-only views of the domain state.</p> <ul> <li>UV coverage displayed</li> <li>Dirty image displayed</li> <li>PSF displayed</li> <li>Model image displayed</li> <li>Residual image displayed</li> <li>Restored image displayed</li> </ul> <p>Views do not trigger domain changes by themselves.</p>"},{"location":"design/domain/event-storming/interactive-experiment/#core-aggregates","title":"Core Aggregates","text":""},{"location":"design/domain/event-storming/interactive-experiment/#experiment","title":"Experiment","text":"<p>Represents a single interactive experiment.</p> <p>Responsibilities:</p> <ul> <li>Owns current configuration</li> <li>Tracks derived products and caches</li> <li>Decides what must be recomputed when parameters change</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#telescope","title":"Telescope","text":"<p>Includes site location, station positions, and derived baselines.</p> <p>Invariants:</p> <ul> <li>Station identifiers are unique</li> <li>Positions share a common coordinate frame</li> <li>Baselines are derived solely from station positions</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#observation","title":"Observation","text":"<p>Includes time and frequency configuration and pointing.</p> <p>Invariants:</p> <ul> <li>Integration time divides observation duration</li> <li>Frequency grid is consistent with channelization</li> <li>Phase center is well-defined</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#skymodel","title":"SkyModel","text":"<p>Defines the true sky used for simulation.</p> <p>Invariants:</p> <ul> <li>Flux units are consistent</li> <li>Spectral models are defined over the observation band</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#measurementmodel","title":"MeasurementModel","text":"<p>Defines corruptions and beam effects.</p> <p>Invariants:</p> <ul> <li>Beam model matches frequency range</li> <li>Corruption parameterization is internally consistent</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#visibilityset","title":"VisibilitySet","text":"<p>Contains predicted, corrupted, and averaged visibilities.</p> <p>Invariants:</p> <ul> <li>Array shapes are consistent across visibilities, flags, and weights</li> <li>UVW coordinates align with time/baseline axes</li> <li>Units are fixed (e.g. meters, Hz)</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#dataproducts","title":"DataProducts","text":"<p>Contains image-plane products.</p> <p>Invariants:</p> <ul> <li>Dirty image, PSF, model, and residual share a common grid</li> <li>Residual = dirty \u2212 (model \u2297 PSF)</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#dependency-recompute-map","title":"Dependency &amp; Recompute Map","text":"<p>This dependency graph determines cache invalidation when parameters change.</p> <p><code>mermaid flowchart LR   A[Telescope] --&gt; U[UVW]   O[Observation] --&gt; U   S[SkyModel] --&gt; Vp[Predicted visibilities]   U --&gt; Vp   I[Corruptions] --&gt; Vc[Corrupted visibilities]   Vp --&gt; Vc   O --&gt; Va[Averaged visibilities]   Vc --&gt; Va   Va --&gt; G[Gridded visibilities]   O --&gt; G   G --&gt; D[Dirty image]   G --&gt; P[PSF]   D --&gt; C[Deconvolution]   P --&gt; C   C --&gt; M[Model image]   C --&gt; R[Residual image]</code></p> <p>Examples:</p> <ul> <li>Changing integration time invalidates averaged visibilities and downstream products.</li> <li>Changing array layout invalidates UVW sampling and everything downstream.</li> <li>Changing beam model invalidates corrupted visibilities and downstream products.</li> <li>Changing imaging weighting invalidates gridded visibilities and image products only.</li> </ul>"},{"location":"design/domain/event-storming/interactive-experiment/#notes-for-implementation","title":"Notes for Implementation","text":"<ul> <li>Widgets issue commands; they do not directly run algorithms.</li> <li>The Experiment aggregate coordinates recomputation.</li> <li>Algorithms remain stateless and reusable.</li> <li>The domain model is independent of notebooks and plotting.</li> </ul> <p>This document serves as the architectural anchor for interactive experiments.</p>"},{"location":"design/requirements/","title":"Requirements","text":"<p>Functional requirements (what the software will do) for Radio Astronomy Playground are formulated as user stories and BDD scenarios. Non-functional requirements (how the software should do it) are formulated as quality scenarios and organised into a utility tree. These will evolve over time.</p> <p>See impact map for how the delivery slices below relate to impacts and goals.</p>"},{"location":"design/requirements/#slice-s1-self-calibration-loop-diagnostics-mvp","title":"Slice S1: Self-calibration loop + diagnostics (MVP)","text":"<ul> <li>User stories</li> <li>Utility tree</li> </ul>"},{"location":"design/requirements/s1-user-stories/","title":"S1: Self-calibration loop + diagnostics (MVP)","text":"<p>This page documents the functional requirements for a minimal viable product (MVP) for Radio Astronomy Playground, corresponding to deliverable slice 1 shown in the impact map. They are formulated as user stories with behaviour-driven-design (BDD) scenarios that form the basis for issues tracked in GitHub and BDD tests respectively.</p>"},{"location":"design/requirements/s1-user-stories/#assumptions","title":"Assumptions","text":"<ul> <li>Calibration is performed at the station level (one complex gain per station) and is phase-only</li> <li>Visibilities are scalar (Stokes I) and stored as complex64/complex128.</li> <li>Visibilities have shape (n_timesteps, n_baselines, n_channels).</li> </ul>"},{"location":"design/requirements/s1-user-stories/#star-001-reproducible-randomly-generated-simulations","title":"STAR-001: Reproducible randomly generated simulations","text":""},{"location":"design/requirements/s1-user-stories/#user-story","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want to simulate data (visibilities) and models (sky model, telescope, observation, corruptions) with a seed</p> <p>so that I can reproduce the same simulation and compare results of different experiments.</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios","title":"BDD scenarios","text":"<ul> <li>Given a simulation configuration with a fixed seed</li> </ul> <p>When I configure the simulation twice</p> <p>Then the sky model, station layout, and observation sampling are identical</p> <ul> <li>Given two simulation configurations with different seeds</li> </ul> <p>When I configure the simulation twice</p> <p>Then at least one of sources or station positions differs</p> <ul> <li>Given a simulation configuration without a seed</li> </ul> <p>When I configure the simulation twice</p> <p>Then the results differ</p>"},{"location":"design/requirements/s1-user-stories/#star-002-predicted-visibilities","title":"STAR-002: Predicted visibilities","text":""},{"location":"design/requirements/s1-user-stories/#user-story_1","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want to predict visibilities from a sky model</p> <p>so that I can understand what an interferometer would observe under perfect conditions and I have a reference dataset for calibration</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios_1","title":"BDD scenarios","text":"<ul> <li>Given a sky model with a single point source at the phase centre</li> </ul> <p>When I predict visibilities</p> <p>Then phase is approximately constant across baselines within tolerance</p> <ul> <li>Given a sky model with a single point source offset from the phase centre</li> </ul> <p>When I predict visibilities</p> <p>Then visibility phase varies with baseline consistent with geometric delay</p>"},{"location":"design/requirements/s1-user-stories/#star-003-corruptions-and-noise-applied-to-visibilities","title":"STAR-003: Corruptions and noise applied to visibilities","text":""},{"location":"design/requirements/s1-user-stories/#user-story_2","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want to apply known phase-only corruptions and noise to visibilities</p> <p>so that I can create controlled \"observed\" visibilities from model visibilities and understand how instrumental effects modify the data</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios_2","title":"BDD scenarios","text":"<ul> <li>Given identity gains and zero noise</li> </ul> <p>When I corrupt model visibilities</p> <p>Then observed visibilities are identical to model visibilities (within tolerance)</p> <ul> <li>Given phase gains and zero noise</li> </ul> <p>When I corrupt model visibilities</p> <p>Then baseline phase differences in corrupted visibilities reflect the applied gains</p> <ul> <li>Given non-zero noise</li> </ul> <p>When I corrupt model visibilities</p> <p>Then observed visibilities differ from model visibilities with the expected RMS level</p>"},{"location":"design/requirements/s1-user-stories/#star-004-solve-for-phase-only-gains","title":"STAR-004: Solve for phase-only gains","text":""},{"location":"design/requirements/s1-user-stories/#user-story_3","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want to solve for phase-only gains with specified time and frequency solution intervals in corrupted visibilities vs. model visibilities</p> <p>so that I can understand how calibration corrects for instrumental effects</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios_3","title":"BDD scenarios","text":"<ul> <li>Given noise-free model visibilities with known phase-only gains applied</li> </ul> <p>When I solve for phase-only gains with correct solution intervals</p> <p>Then solved gains match the applied gains</p> <ul> <li>Given noisy model visibilities with known phase-only gains applied</li> </ul> <p>When I solve for phase-only gains with correct solution intervals</p> <p>Then there are no NaN or Inf values in the solutions</p>"},{"location":"design/requirements/s1-user-stories/#star-005-apply-phase-only-calibration-solutions","title":"STAR-005: Apply phase-only calibration solutions","text":""},{"location":"design/requirements/s1-user-stories/#user-story_4","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want to apply phase-only calibration solutions to corrupted visibilities to generate corrected visibilities</p> <p>so that I can understand how calibration corrects for instrumental effects</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios_4","title":"BDD scenarios","text":"<ul> <li>Given noise-free model visibilities with known phase-only gains applied and calibration solutions</li> </ul> <p>When I apply the calibration solutions</p> <p>Then corrected visibilities match model visibilities</p> <ul> <li>Given noisy model visibilities with known phase-only gains applied and calibration solutions</li> </ul> <p>When I apply the calibration solutions</p> <p>Then there are no NaN or Inf values and corrected visibilities have the expected RMS level</p>"},{"location":"design/requirements/s1-user-stories/#star-006-image-visibilities","title":"STAR-006: Image visibilities","text":""},{"location":"design/requirements/s1-user-stories/#user-story_5","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want to generate images of model, observed and corrected visibilities</p> <p>so that I can inspect the impact of calibration and instrumental effects</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios_5","title":"BDD scenarios","text":"<ul> <li>Given visibilities of a point source at the phase centre</li> </ul> <p>When I generate an image</p> <p>Then the brightest pixel is in the centre of the image</p> <ul> <li>Given predicted visibilities from a sky model of 3-5 bright point sources</li> </ul> <p>When I generate an image</p> <p>Then the positions of the brightest pixels align with the positions of the point sources in the sky model image</p> <ul> <li>Given corrupted visibilities before and after calibration solutions are applied</li> </ul> <p>When I generate images for each visibility set</p> <p>Then the image of visibilities after calibration is closer to the image of the sky model</p>"},{"location":"design/requirements/s1-user-stories/#star-007-diagnostic-plots-and-statistics","title":"STAR-007: Diagnostic plots and statistics","text":""},{"location":"design/requirements/s1-user-stories/#user-story_6","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want summary statistics and plots of diagnostic metrics after every self-calibration loop</p> <p>so that I can evaluate convergence, divergence, over-fitting and failures of self-calibration</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios_6","title":"BDD scenarios","text":"<ul> <li>Given a completed self-calibration loop</li> </ul> <p>When I request diagnostics</p> <p>Then I get: images and statistics on residuals before and after calibration and plots of phase gain vs. time for selected stations.</p> <ul> <li>Given a failed self-calibration loop</li> </ul> <p>When I request diagnostics</p> <p>Then the diagnostics have at least one warning indicating a failure.</p>"},{"location":"design/requirements/s1-user-stories/#star-008-save-and-load-experiments","title":"STAR-008: Save and load experiments","text":""},{"location":"design/requirements/s1-user-stories/#user-story_7","title":"User story","text":"<p>As a Radio Astronomy Learner</p> <p>I want to save and reload an experiment</p> <p>so that I can re-inspect results and compare to other experiments</p>"},{"location":"design/requirements/s1-user-stories/#bdd-scenarios_7","title":"BDD scenarios","text":"<ul> <li>Given a completed self-calibration experiment</li> </ul> <p>When I save the plots, configuration and final calibration loop datasets and reload them later</p> <p>Then I get the same plots, configuration and data sets and can regenerate the same diagnostic outputs</p> <ul> <li>Given two completed self-calibration experiments</li> </ul> <p>When I reload both</p> <p>Then I can compare results side-by-side</p>"},{"location":"design/requirements/s1-user-stories/#acceptance-criteria-for-mvp","title":"Acceptance criteria for MVP","text":"<ol> <li>Results and diagnostics for at least one for each of the following self-calibration runs are saved and can be reloaded:<ul> <li>Converged: images stop improving and solutions are stable over time</li> <li>diverged: images start to get worse and solutions become less stable over iterations</li> <li>failed: valid solutions cannot be found</li> <li>overfitted: images improve but solutions become less stable over time</li> </ul> </li> <li>Each run can be reproduced from a notebook</li> </ol>"},{"location":"design/requirements/s1-user-stories/#out-of-scope-mvp","title":"Out of scope (MVP)","text":"<ul> <li>Beam/DDE effects</li> <li>w-term correction</li> <li>CLEAN/deconvolution</li> <li>Full-Jones calibration</li> <li>Distributed execution / large datasets</li> <li>Dashboard UI</li> </ul>"},{"location":"design/requirements/s1-utility-tree/","title":"S1: Self-calibration loop + diagnostics (MVP)","text":"<p>This page documents the non-functional requirements for a minimal viable product (MVP) for Radio Astronomy Playground, corresponding to deliverable slice 1 shown in the impact map. They are formulated as quality attribute scenarios and organised into a utility tree.</p> <p>The main goal of Radio Astronomy Playground is to build intuition for self-calibration and imaging. Qualities that facilitate learning are therefore prioritised over performance.</p>"},{"location":"design/requirements/s1-utility-tree/#quality-attributes","title":"Quality attributes","text":"<ul> <li>Reproducibility: running the same configuration, inputs, and random seed generates identical results</li> <li>Inspectability: data can be inspected before and after each transformation</li> <li>Testability: automated tests verify behaviour defined by BDD scenarios, enabling safe refactoring and regression detection.</li> <li>Scientific validity: assumptions and limitations are clear and diagnostics are not open to misinterpretation</li> <li>Modularity: software has components with clear boundaries and stable interfaces so that core domain logic can evolve independently of UI and visualisation choices</li> </ul>"},{"location":"design/requirements/s1-utility-tree/#utility-tree","title":"Utility tree","text":"<p>The following organises quality attributes into a tree that branches into specific quality attribute issues. The issues are ranked for high (H), medium (M) or low (L) importance and difficulty.  <pre><code>graph LR\n  U[\"Utility (S1): Maximise learning\"]\n\n  U --&gt; R[\"Reproducibility (H)\"]\n  U --&gt; INSP[\"Inspectability (H)\"]\n  U --&gt; TEST[\"Testability (H)\"]\n  U --&gt; VAL[\"Scientific validity (H)\"]\n  U --&gt; MOD[\"Modularity (H)\"]\n\n  %% Reproducibility\n  R --&gt; R1[\"R1: Deterministic simulation from config+seed (H, M)\"]\n  R --&gt; R2[\"R2: Experiment replay from saved run (H, M)\"]\n\n  %% Inspectability\n  INSP --&gt; I1[\"I1: Inspect self-calibration iteration state (gains, residuals, images) (H, M)\"]\n\n  %% Testability\n  TEST --&gt; T1[\"T1: BDD scenarios map to automated tests (H, M)\"]\n\n  %% Scientific validity\n  VAL --&gt; V1[\"V1: Assumptions/limitations explicit (H, L)\"]\n  VAL --&gt; V2[\"V2: Diagnostics include warnings for failure/overfit/divergence (H, M)\"]\n\n  %% Modularity\n  MOD --&gt; M1[\"M1: Core domain logic independent of UI/viz (H, M)\"]</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom  </p>"},{"location":"design/requirements/s1-utility-tree/#quality-attribute-scenarios","title":"Quality Attribute Scenarios","text":""},{"location":"design/requirements/s1-utility-tree/#qas-001-inspectability-i1","title":"QAS-001 \u2014 Inspectability (I1)","text":"<p>Quality attribute: Inspectability</p> <p>Stimulus: A self-calibration iteration completes.</p> <p>Context: The system is running in exploratory mode during an interactive experiment.</p> <p>Artifact: Self-calibration loop state (gain solutions, residual visibilities, images).</p> <p>Response: The system exposes the gain solutions, residual visibilities, and images produced by that iteration without recomputing previous iterations.</p> <p>Response measure: Per-iteration artifacts are accessible via the experiment or pipeline API, and accessing them does not trigger recomputation of earlier iterations.</p>"},{"location":"design/requirements/s1-utility-tree/#qas-002-testability-t1","title":"QAS-002 \u2014 Testability (T1)","text":"<p>Quality attribute: Testability</p> <p>Stimulus: BDD-based regression tests are executed.</p> <p>Context: The system is running in CI using simulation fixtures and fixed random seeds.</p> <p>Artifact: Visibility prediction outputs, calibration solutions, and diagnostic metrics.</p> <p>Response: The system produces reproducible outputs and fails tests when results deviate beyond defined tolerance bounds.</p> <p>Response measure: CI fails if any numeric output exceeds configured tolerance thresholds; otherwise, all tests pass deterministically across repeated CI runs.</p>"},{"location":"design/requirements/s1-utility-tree/#qas-003-reproducibility-r1","title":"QAS-003 \u2014 Reproducibility (R1)","text":"<p>Quality attribute: Reproducibility</p> <p>Stimulus: A simulation is generated using a configuration with an explicit random seed.</p> <p>Context: The system is running under the same code version and runtime environment.</p> <p>Artifact: Sky model, station layout, observation and predicted visibilities.</p> <p>Response: The system generates identical artifacts across repeated runs.</p> <p>Response measure: All generated artifacts are numerically identical within tolerance across repeated executions.</p>"},{"location":"design/requirements/s1-utility-tree/#qas-004-reproducibility-r2","title":"QAS-004 \u2014 Reproducibility (R2)","text":"<p>Quality attribute: Reproducibility</p> <p>Stimulus: A previously saved experiment run is loaded.</p> <p>Context: The system is running in a new session without recomputing simulation or calibration steps.</p> <p>Artifact: Saved experiment configuration, per-iteration outputs, and diagnostics.</p> <p>Response: The system reconstructs the artifacts required to regenerate diagnostics and analyses.</p> <p>Response measure: Regenerated diagnostics match the original outputs within tolerance, without invoking recomputation.</p>"},{"location":"design/requirements/s1-utility-tree/#qas-005-scientific-validity-v1","title":"QAS-005 \u2014 Scientific Validity (V1)","text":"<p>Quality attribute: Scientific validity</p> <p>Stimulus: A user runs an MVP experiment.</p> <p>Context: The experiment relies on simplified assumptions (e.g. scalar Stokes I, no w-term, no DDE, no CLEAN).</p> <p>Artifact: Experiment outputs (images, diagnostics, calibration solutions).</p> <p>Response: The system presents the active assumptions and known limitations alongside the results.</p> <p>Response measure: All outputs visibly include the active assumptions and out-of-scope effects at the time results are displayed.</p>"},{"location":"design/requirements/s1-utility-tree/#qas-006-scientific-validity-v2","title":"QAS-006 \u2014 Scientific Validity (V2)","text":"<p>Quality attribute: Scientific validity</p> <p>Stimulus: Diagnostics are generated for a self-calibration iteration or completed run.</p> <p>Context: The run exhibits indicators of failure, divergence, or overfitting.</p> <p>Artifact: Diagnostic metrics and summary reports.</p> <p>Response: The system emits warnings linked to specific measurable triggers and thresholds.</p> <p>Response measure: Each warning references at least one metric and threshold, and warnings are present whenever predefined failure conditions are met.</p>"},{"location":"design/requirements/s1-utility-tree/#qas-007-modularity-m1","title":"QAS-007 \u2014 Modularity (M1)","text":"<p>Quality attribute: Modularity</p> <p>Stimulus: The core library is imported and executed.</p> <p>Context: UI and visualisation dependencies are not installed.</p> <p>Artifact: Core simulation, prediction, and calibration modules.</p> <p>Response: The system imports and executes core functionality without requiring UI or visualisation libraries.</p> <p>Response measure: All core modules import successfully and pass functional tests in an environment where UI dependencies are absent.</p>"},{"location":"design/vision/","title":"Vision","text":"<ul> <li>Impact Map</li> </ul>"},{"location":"design/vision/impact-map/","title":"Impact map","text":"<p>Calibration and imaging workflows in radio astronomy are complex, involving many interacting parameters and iterative decision-making. This expert knowledge must be encoded into production pipelines. This project is explicitly focused on building intuition for these processes, especially self-calibration, through controlled, interactive experiments and diagnostics.</p> <p>The impact map below captures the main goal of the project and links it to who it is designed for (a learner of radio astronomy), the behavioural impacts we want to enable and the deliverable slices that support those impacts.</p> <p>The map is not a fixed feature roadmap or a complete product specification. It is a tool for prioritising what to implement next and a way to keep development focused on learning outcomes. The map will evolve over time as experiments reveal misconceptions and incorrect assumptions.</p> <pre><code>flowchart LR\n  subgraph GOALS[Goals]\n    G1[\"Build intuition for self-calibration and imaging\"]\n  end\n\n  subgraph ACTORS[Actors]\n    A1[\"Radio Astronomy Learner\"]\n  end\n\n  subgraph IMPACTS[Impacts]\n    I1[\"Detect self-cal improvement vs overfitting\"]\n    I2[\"Diagnose causes of self-cal divergence\"]\n    I3[\"Interpret gain solutions for stability and plausibility\"]\n    I4[\"Relate uv coverage and residuals to image artefacts\"]\n    I5[\"Choose appropriate calibration parameters\"]\n    I6[\"Assess scientific image quality using multiple metrics\"]\n    I7[\"Recognise when beam/DDE effects dominate errors\"]\n  end\n\n  subgraph SLICES[Deliverable Slices]\n    S1[\"S1: Self-cal loop + diagnostics (MVP)\"]\n    S2[\"S2: Calibration parameter sweeps\"]\n    S3[\"S3: Imaging artefact lab\"]\n    S4[\"S4: Beam / DDE lab\"]\n  end\n\n  G1 --&gt; A1\n  A1 --&gt; I1 &amp; I2 &amp; I3 &amp; I4 &amp; I5 &amp; I6 &amp; I7\n\n  I1 --&gt; S1\n  I2 --&gt; S1\n  I3 --&gt; S1\n  I4 --&gt; S1\n\n  I1 --&gt; S2\n  I2 --&gt; S2\n  I5 --&gt; S2\n\n  I4 --&gt; S3\n  I6 --&gt; S3\n\n  I7 --&gt; S4\n\n  S1 --&gt; S2 --&gt; S3 --&gt; S4</code></pre>  Hold \"Alt\" / \"Option\" to enable pan &amp; zoom"},{"location":"design/vision/impact-map/#minimum-viable-learning-loop-mvp","title":"Minimum Viable Learning Loop (MVP)","text":"<p>The initial implementation focuses on Slice S1: Self-cal loop + diagnostics. This slice establishes the minimal end-to-end loop required to:</p> <ol> <li>Simulate sky model with 1-5 point sources</li> <li>Simulate telescope, a few stations</li> <li>Simulate observation, a few channels, a few hours</li> <li>Predict visibilities from sky model, no w-term</li> <li>Add phase-only corruptions and noise to visibilities</li> <li>Solve for and apply calibration solutions</li> <li>Image the result before and after calibration</li> <li>Evaluate outcomes using multiple diagnostics</li> <li>Save an experiment so that it is easy to re-load and inspect later</li> </ol> <p>All subsequent slices depend on this loop. Features not directly supporting this slice are intentionally deferred.</p> <ul> <li>S1 user stores</li> <li>S1 utility tree</li> </ul>"},{"location":"explanation/","title":"Explanation","text":""},{"location":"how-to/","title":"How-To","text":"<ul> <li>How to get started</li> </ul>"},{"location":"how-to/get-started/","title":"How to get started with Radio Astronomy Playground","text":"<p>This guide shows you how to install <code>starbox</code>, the core python library of Radio Astronomy Playground, and its dependencies and run the get started notebook, which will demonstrate how to run an experiment in radio astronomy data processing.</p>"},{"location":"how-to/get-started/#pre-requisites","title":"Pre-requisites","text":"<ol> <li>git</li> <li>uv</li> </ol>"},{"location":"how-to/get-started/#steps","title":"Steps","text":"<ol> <li>Clone this repository:    <pre><code>git clone git@github.com:gemmadanks/radio-astronomy-playground.git\n</code></pre></li> <li>Install starbox and its dependencies:    <pre><code>uv sync\n</code></pre></li> <li>Run the <code>get-started.py</code> notebook to conduct your first experiment:    <pre><code>uv run marimo run notebooks/get-started.py\n</code></pre></li> </ol>"},{"location":"reference/","title":"API","text":""},{"location":"reference/#starbox.calibrate","title":"<code>starbox.calibrate</code>","text":"<p>Radio telescope visibility calibration components.</p> <p>This module provides classes and functions for calibrating radio telescope visibility data.</p> <p>Classes:</p> Name Description <code>Solutions</code> <p>Class for handling calibration solutions.</p> <code>Solver</code> <p>Class for solving for calibration solutions.</p>"},{"location":"reference/#starbox.calibrate.Solutions","title":"<code>Solutions</code>  <code>dataclass</code>","text":"<p>Class for handling calibration solutions.</p> <p>Attributes:</p> Name Type Description <code>station_phase_gains</code> <code>ndarray</code> <p>Phase gains for each station.</p> Source code in <code>src/starbox/calibrate/solutions.py</code> <pre><code>@dataclass(slots=True)\nclass Solutions:\n    \"\"\"Class for handling calibration solutions.\n\n    Attributes:\n        station_phase_gains: Phase gains for each station.\n    \"\"\"\n\n    station_phase_gains: np.ndarray\n\n    def apply(self, visibilities: VisibilitySet) -&gt; VisibilitySet:\n        \"\"\"Apply calibration solutions to visibilities.\"\"\"\n\n        # Placeholder implementation: return visibilities unchanged\n        return visibilities\n</code></pre>"},{"location":"reference/#starbox.calibrate.Solutions.apply","title":"<code>apply(visibilities)</code>","text":"<p>Apply calibration solutions to visibilities.</p> Source code in <code>src/starbox/calibrate/solutions.py</code> <pre><code>def apply(self, visibilities: VisibilitySet) -&gt; VisibilitySet:\n    \"\"\"Apply calibration solutions to visibilities.\"\"\"\n\n    # Placeholder implementation: return visibilities unchanged\n    return visibilities\n</code></pre>"},{"location":"reference/#starbox.calibrate.Solver","title":"<code>Solver</code>","text":"<p>Class to handle calibration solving.</p> Source code in <code>src/starbox/calibrate/solver.py</code> <pre><code>class Solver:\n    \"\"\"Class to handle calibration solving.\"\"\"\n\n    def __init__(self, config: SolverConfig):\n        self.config = config\n\n    def solve(\n        self,\n        observed_visibilities: VisibilitySet,\n        model_visibilities: VisibilitySet,\n        n_stations: int,\n    ) -&gt; Solutions:\n        \"\"\"Estimate calibration solutions from observed and model visibilities.\"\"\"\n\n        n_timesteps, _, n_channels = observed_visibilities.vis.shape\n\n        # Default: solve per timestep / per channel\n        tbin = self.config.solution_interval_seconds or 1\n\n        n_time_bins = int(np.ceil(n_timesteps / tbin))\n        n_freq_bins = int(np.ceil(n_channels / 1))\n\n        # Just return unity gains (phase = 0)\n        gains = np.ones(\n            (n_time_bins, n_freq_bins, n_stations),\n            dtype=np.complex64,\n        )\n        return Solutions(station_phase_gains=gains)\n</code></pre>"},{"location":"reference/#starbox.calibrate.Solver.solve","title":"<code>solve(observed_visibilities, model_visibilities, n_stations)</code>","text":"<p>Estimate calibration solutions from observed and model visibilities.</p> Source code in <code>src/starbox/calibrate/solver.py</code> <pre><code>def solve(\n    self,\n    observed_visibilities: VisibilitySet,\n    model_visibilities: VisibilitySet,\n    n_stations: int,\n) -&gt; Solutions:\n    \"\"\"Estimate calibration solutions from observed and model visibilities.\"\"\"\n\n    n_timesteps, _, n_channels = observed_visibilities.vis.shape\n\n    # Default: solve per timestep / per channel\n    tbin = self.config.solution_interval_seconds or 1\n\n    n_time_bins = int(np.ceil(n_timesteps / tbin))\n    n_freq_bins = int(np.ceil(n_channels / 1))\n\n    # Just return unity gains (phase = 0)\n    gains = np.ones(\n        (n_time_bins, n_freq_bins, n_stations),\n        dtype=np.complex64,\n    )\n    return Solutions(station_phase_gains=gains)\n</code></pre>"},{"location":"reference/#starbox.config","title":"<code>starbox.config</code>","text":"<p>Module for configuration schemas.</p> Exports <ul> <li>ObservationConfig: Configuration schema for observations.</li> <li>SkyModelConfig: Configuration schema for sky models.</li> <li>TelescopeConfig: Configuration schema for telescopes.</li> <li>CorruptionsConfig: Configuration schema for corruptions.</li> <li>SolverConfig: Configuration schema for solvers.</li> <li>ExperimentConfig: Configuration schema for experiments.</li> </ul>"},{"location":"reference/#starbox.config.CorruptionsConfig","title":"<code>CorruptionsConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration schema for the Corruptions.</p> Source code in <code>src/starbox/config/corruptions.py</code> <pre><code>class CorruptionsConfig(BaseModel):\n    \"\"\"Configuration schema for the Corruptions.\"\"\"\n\n    seed: int = Field(ge=0)\n    rms_noise: float = Field(ge=0)\n    rms_phase_gain: float = Field(ge=0)\n</code></pre>"},{"location":"reference/#starbox.config.ExperimentConfig","title":"<code>ExperimentConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration for a simulation experiment.</p> Source code in <code>src/starbox/config/experiment.py</code> <pre><code>class ExperimentConfig(BaseModel):\n    \"\"\"Configuration for a simulation experiment.\"\"\"\n\n    name: str = Field(..., description=\"Name of the experiment.\")\n    description: str | None = Field(\n        None, description=\"Optional description of the experiment.\"\n    )\n    telescope: TelescopeConfig = Field(\n        ..., description=\"Configuration for the telescope array.\"\n    )\n    skymodel: SkyModelConfig = Field(\n        ..., description=\"Configuration for the sky model.\"\n    )\n    observation: ObservationConfig = Field(\n        ..., description=\"Configuration for the observation.\"\n    )\n    corruptions: CorruptionsConfig = Field(\n        ..., description=\"Configuration for the corruptions to apply.\"\n    )\n    solver: SolverConfig = Field(\n        ..., description=\"Configuration for the calibration solver.\"\n    )\n</code></pre>"},{"location":"reference/#starbox.config.ObservationConfig","title":"<code>ObservationConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration schema for the Observation.</p> Source code in <code>src/starbox/config/observation.py</code> <pre><code>class ObservationConfig(BaseModel):\n    \"\"\"Configuration schema for the Observation.\"\"\"\n\n    start_time: float = Field(ge=0)\n    observation_length: float = Field(gt=0)\n    num_timesteps: int = Field(ge=1)\n    start_frequency: float = Field(gt=0)\n    num_channels: int = Field(ge=1)\n    total_bandwidth: float = Field(gt=0)\n</code></pre>"},{"location":"reference/#starbox.config.SkyModelConfig","title":"<code>SkyModelConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration schema for the SkyModel.</p> Source code in <code>src/starbox/config/skymodel.py</code> <pre><code>class SkyModelConfig(BaseModel):\n    \"\"\"Configuration schema for the SkyModel.\"\"\"\n\n    num_sources: int = Field(gt=0)\n    max_flux_jy: float = Field(gt=0)\n    phase_centre_deg: tuple[float, float] = Field(default=(0, 0))\n    fov_deg: float = Field(gt=0)\n    seed: int = Field(ge=0)\n</code></pre>"},{"location":"reference/#starbox.config.SolverConfig","title":"<code>SolverConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration schema for the solver.</p> Source code in <code>src/starbox/config/solver.py</code> <pre><code>class SolverConfig(BaseModel):\n    \"\"\"Configuration schema for the solver.\"\"\"\n\n    solution_interval_seconds: float = Field(\n        gt=0, description=\"Solution interval in seconds.\"\n    )\n</code></pre>"},{"location":"reference/#starbox.config.TelescopeConfig","title":"<code>TelescopeConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration schema for the Telescope.</p> Source code in <code>src/starbox/config/telescope.py</code> <pre><code>class TelescopeConfig(BaseModel):\n    \"\"\"Configuration schema for the Telescope.\"\"\"\n\n    num_stations: int = Field(gt=0)\n    diameter: float = Field(gt=0)\n    seed: int = Field(ge=0)\n</code></pre>"},{"location":"reference/#starbox.factory","title":"<code>starbox.factory</code>","text":"<p>Module for building simulation components.</p> <p>Functions to build sky models, observations, and telescopes.</p> Exports <ul> <li>build_skymodel: Function to build sky models.</li> <li>build_observation: Function to build observations.</li> <li>build_telescope: Function to build telescopes.</li> <li>build_corruptions: Function to build corruptions.</li> <li>build_solver: Function to build solvers.</li> </ul>"},{"location":"reference/#starbox.factory.build_corruptions","title":"<code>build_corruptions(cfg)</code>","text":"<p>Build a Corruptions instance from a CorruptionsConfig.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>CorruptionsConfig</code> <p>The CorruptionsConfig instance.</p> required <p>Returns:     A Corruptions instance.</p> Source code in <code>src/starbox/factory/corruptions.py</code> <pre><code>def build_corruptions(cfg: CorruptionsConfig) -&gt; Corruptions:\n    \"\"\"Build a Corruptions instance from a CorruptionsConfig.\n\n    Args:\n        cfg: The CorruptionsConfig instance.\n    Returns:\n        A Corruptions instance.\n    \"\"\"\n    return Corruptions(cfg)\n</code></pre>"},{"location":"reference/#starbox.factory.build_observation","title":"<code>build_observation(config)</code>","text":"<p>Build an Observation from its configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>ObservationConfig</code> <p>The Observation configuration.</p> required <p>Returns:     The built Observation.</p> Source code in <code>src/starbox/factory/observation.py</code> <pre><code>def build_observation(config: ObservationConfig) -&gt; Observation:\n    \"\"\"Build an Observation from its configuration.\n\n    Args:\n        config: The Observation configuration.\n    Returns:\n        The built Observation.\n    \"\"\"\n    return Observation(config)\n</code></pre>"},{"location":"reference/#starbox.factory.build_skymodel","title":"<code>build_skymodel(cfg)</code>","text":"<p>Build a SkyModel from a SkyModelConfig.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>SkyModelConfig</code> <p>Configuration for the sky model.</p> required <p>Returns:</p> Name Type Description <code>SkyModel</code> <code>SkyModel</code> <p>The constructed sky model.</p> Source code in <code>src/starbox/factory/skymodel.py</code> <pre><code>def build_skymodel(cfg: SkyModelConfig) -&gt; SkyModel:\n    \"\"\"Build a SkyModel from a SkyModelConfig.\n\n    Args:\n        cfg (SkyModelConfig): Configuration for the sky model.\n\n    Returns:\n        SkyModel: The constructed sky model.\n    \"\"\"\n    return SkyModel(config=cfg)\n</code></pre>"},{"location":"reference/#starbox.factory.build_solver","title":"<code>build_solver(cfg)</code>","text":"<p>Build a Solver instance from the given configuration.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>SolverConfig</code> <p>Configuration for the solver.</p> required <p>Returns:     An instance of Solver.</p> Source code in <code>src/starbox/factory/solver.py</code> <pre><code>def build_solver(cfg: SolverConfig) -&gt; Solver:\n    \"\"\"Build a Solver instance from the given configuration.\n\n    Args:\n        cfg: Configuration for the solver.\n    Returns:\n        An instance of Solver.\n    \"\"\"\n    return Solver(cfg)\n</code></pre>"},{"location":"reference/#starbox.factory.build_telescope","title":"<code>build_telescope(cfg, name='Telescope')</code>","text":"<p>Build a Telescope from a TelescopeConfig.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>TelescopeConfig</code> <p>Configuration for the telescope.</p> required <p>Returns:</p> Name Type Description <code>Telescope</code> <code>Telescope</code> <p>The constructed telescope.</p> Source code in <code>src/starbox/factory/telescope.py</code> <pre><code>def build_telescope(cfg: TelescopeConfig, name=\"Telescope\") -&gt; Telescope:\n    \"\"\"Build a Telescope from a TelescopeConfig.\n\n    Args:\n        cfg (TelescopeConfig): Configuration for the telescope.\n\n    Returns:\n        Telescope: The constructed telescope.\n    \"\"\"\n    return Telescope(cfg, name=name)\n</code></pre>"},{"location":"reference/#starbox.image","title":"<code>starbox.image</code>","text":"<p>Radio telescope visibility imaging components.</p> <p>This module provides classes and functions for creating images from radio telescope visibility data.</p> <p>Classes:</p> Name Description <code>Imager</code> <p>Class for gridding and imaging radio telescope visibilities.</p>"},{"location":"reference/#starbox.image.Imager","title":"<code>Imager</code>","text":"<p>Class for handling image processing.</p> Source code in <code>src/starbox/image/imager.py</code> <pre><code>class Imager:\n    \"\"\"Class for handling image processing.\"\"\"\n\n    def __init__(self, grid_size: int = 256):\n        \"\"\"Initialize the Imager with default grid size.\"\"\"\n        self.grid_size = grid_size\n\n    def grid(self, visibilities: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Grid the visibilities onto a regular grid.\"\"\"\n        gridded_visibilities = np.ones((self.grid_size, self.grid_size), dtype=complex)\n\n        return gridded_visibilities\n\n    def ifft(self, gridded_visibilities: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Convert gridded visibilities to an image using an inverse 2D Fourier transform.\n\n        This applies np.fft.ifft2 to transform data from Fourier (uv) space to image space,\n        recenters the zero-frequency component with fftshift, and returns the image magnitude.\n        \"\"\"\n        # Assuming gridded visibilities is a 2D numpy array\n        image = np.fft.ifft2(gridded_visibilities)\n        image = np.fft.fftshift(image)\n        return np.abs(image)\n\n    def image(self, visibilities: VisibilitySet) -&gt; np.ndarray:\n        \"\"\"Create an image from visibilities.\"\"\"\n        gridded_visibilities = self.grid(visibilities=visibilities.vis)\n        image = self.ifft(gridded_visibilities)\n        return image\n</code></pre>"},{"location":"reference/#starbox.image.Imager.__init__","title":"<code>__init__(grid_size=256)</code>","text":"<p>Initialize the Imager with default grid size.</p> Source code in <code>src/starbox/image/imager.py</code> <pre><code>def __init__(self, grid_size: int = 256):\n    \"\"\"Initialize the Imager with default grid size.\"\"\"\n    self.grid_size = grid_size\n</code></pre>"},{"location":"reference/#starbox.image.Imager.grid","title":"<code>grid(visibilities)</code>","text":"<p>Grid the visibilities onto a regular grid.</p> Source code in <code>src/starbox/image/imager.py</code> <pre><code>def grid(self, visibilities: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Grid the visibilities onto a regular grid.\"\"\"\n    gridded_visibilities = np.ones((self.grid_size, self.grid_size), dtype=complex)\n\n    return gridded_visibilities\n</code></pre>"},{"location":"reference/#starbox.image.Imager.ifft","title":"<code>ifft(gridded_visibilities)</code>","text":"<p>Convert gridded visibilities to an image using an inverse 2D Fourier transform.</p> <p>This applies np.fft.ifft2 to transform data from Fourier (uv) space to image space, recenters the zero-frequency component with fftshift, and returns the image magnitude.</p> Source code in <code>src/starbox/image/imager.py</code> <pre><code>def ifft(self, gridded_visibilities: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Convert gridded visibilities to an image using an inverse 2D Fourier transform.\n\n    This applies np.fft.ifft2 to transform data from Fourier (uv) space to image space,\n    recenters the zero-frequency component with fftshift, and returns the image magnitude.\n    \"\"\"\n    # Assuming gridded visibilities is a 2D numpy array\n    image = np.fft.ifft2(gridded_visibilities)\n    image = np.fft.fftshift(image)\n    return np.abs(image)\n</code></pre>"},{"location":"reference/#starbox.image.Imager.image","title":"<code>image(visibilities)</code>","text":"<p>Create an image from visibilities.</p> Source code in <code>src/starbox/image/imager.py</code> <pre><code>def image(self, visibilities: VisibilitySet) -&gt; np.ndarray:\n    \"\"\"Create an image from visibilities.\"\"\"\n    gridded_visibilities = self.grid(visibilities=visibilities.vis)\n    image = self.ifft(gridded_visibilities)\n    return image\n</code></pre>"},{"location":"reference/#starbox.io","title":"<code>starbox.io</code>","text":"<p>I/O module.</p> <p>Contains functions and classes for reading and writing configuration files.</p> <p>Functions:</p> Name Description <code>- save</code> <p>Save experiment configuration data to a file.</p>"},{"location":"reference/#starbox.predict","title":"<code>starbox.predict</code>","text":"<p>Radio telescope visibility prediction components.</p> <p>This module provides functions for predicting radio telescope visibility data.</p> <p>Functions:</p> Name Description <code>predict_visibilities</code> <p>Function to predict visibilities.</p>"},{"location":"reference/#starbox.predict.predict_visibilities","title":"<code>predict_visibilities(telescope, skymodel, observation)</code>","text":"<p>Predict visibilities given a telescope, sky model, and observation.</p> Source code in <code>src/starbox/predict/predict.py</code> <pre><code>def predict_visibilities(\n    telescope: Telescope, skymodel: SkyModel, observation: Observation\n) -&gt; VisibilitySet:\n    \"\"\"Predict visibilities given a telescope, sky model, and observation.\"\"\"\n\n    # Placeholder implementation: return zeros\n    num_stations = telescope.config.num_stations\n    num_times = len(observation.times)\n    num_channels = len(observation.frequencies)\n    num_baselines = num_stations * (num_stations - 1) // 2\n    station1_index, station2_index = np.triu_indices(\n        num_stations, k=1\n    )  # strictly upper triangle\n\n    visibilities = np.zeros((num_times, num_baselines, num_channels), dtype=complex)\n    visibilities_set = VisibilitySet(\n        vis=visibilities,\n        uvw_m=np.zeros((num_times, num_baselines, 3)),\n        station1=station1_index,\n        station2=station2_index,\n        times_mjd=observation.times,\n        freqs_hz=observation.frequencies,\n        weights=np.ones((num_times, num_baselines, num_channels)),\n    )\n    return visibilities_set\n</code></pre>"},{"location":"reference/#starbox.simulate","title":"<code>starbox.simulate</code>","text":"<p>Radio telescope simulation components.</p> <p>This module provides classes and functions for simulating random radio telescope array configurations and sky models.</p> <p>Classes:</p> Name Description <code>Telescope</code> <p>A class representing a radio telescope array with random         antenna configurations.</p> <code>SkyModel</code> <p>A class for simulating sky models with random sources.</p> <code>Observation</code> <p>A class representing an observation setup including          time and frequency parameters.</p> <code>Corruptions</code> <p>A class for simulating corruptions to the observed signal.</p> <p>Functions:</p> Name Description <code>_compute_coordinates</code> <p>Helper function to calculate antenna coordinates from                  polar coordinates.</p>"},{"location":"reference/#starbox.simulate.Corruptions","title":"<code>Corruptions</code>","text":"<p>A class representing corruptions to apply to a signal.</p> <p>Attributes:</p> Name Type Description <code>rms_noise</code> <p>The RMS noise level to add to the visibilities.</p> <code>station_phase_gain</code> <p>Phase gain errors for each station.</p> Source code in <code>src/starbox/simulate/corruptions.py</code> <pre><code>class Corruptions:\n    \"\"\"A class representing corruptions to apply to a signal.\n\n    Attributes:\n        rms_noise: The RMS noise level to add to the visibilities.\n        station_phase_gain: Phase gain errors for each station.\n    \"\"\"\n\n    def __init__(self, config: CorruptionsConfig):\n        self.config = config\n        self.rng = np.random.default_rng(self.config.seed)\n        self._add_noise()\n        self._add_station_phase_gain()\n\n    def _add_noise(self):\n        \"\"\"Add Gaussian noise corruption.\"\"\"\n        self.sigma = (\n            self.config.rms_noise / np.sqrt(2)\n            if self.config.rms_noise is not None\n            else None\n        )\n\n    def _add_station_phase_gain(self):\n        \"\"\"Add station phase gain corruption.\"\"\"\n        self.rms_phase_gain = (\n            self.config.rms_phase_gain\n            if self.config.rms_phase_gain is not None\n            else None\n        )\n\n    def apply(self, visibility_set: VisibilitySet) -&gt; VisibilitySet:\n        \"\"\"Apply the corruptions to the given visibilities.\"\"\"\n        corrupted_visibility_set = VisibilitySet(\n            vis=np.copy(visibility_set.vis),\n            uvw_m=visibility_set.uvw_m,\n            station1=visibility_set.station1,\n            station2=visibility_set.station2,\n            times_mjd=visibility_set.times_mjd,\n            freqs_hz=visibility_set.freqs_hz,\n            weights=visibility_set.weights,\n        )\n        if self.rms_phase_gain is not None:\n            station_phase_gains = self._sample_station_phase_gains(\n                num_stations=visibility_set.num_stations\n            )\n            corrupted_visibility_set = self._apply_station_phase_gain(\n                corrupted_visibility_set, station_phase_gains\n            )\n\n        if self.sigma is not None:\n            corrupted_visibility_set = self._apply_noise(corrupted_visibility_set)\n\n        return corrupted_visibility_set\n\n    def _apply_station_phase_gain(\n        self, visibility_set: VisibilitySet, station_phase_gains: np.ndarray\n    ) -&gt; VisibilitySet:\n        \"\"\"Apply only the station phase gain corruption to the given visibilities.\"\"\"\n\n        phase_gains_1 = station_phase_gains[visibility_set.station1]\n        phase_gains_2 = station_phase_gains[visibility_set.station2]\n        # Broadcast station gains to all times and channels\n        phase_gains_1 = phase_gains_1[np.newaxis, :, np.newaxis]\n        phase_gains_2 = phase_gains_2[np.newaxis, :, np.newaxis]\n        visibility_set.vis *= phase_gains_1 * np.conj(phase_gains_2)\n\n        return visibility_set\n\n    def _sample_station_phase_gains(self, num_stations: int) -&gt; np.ndarray:\n        \"\"\"Sample random phase gains for each station.\"\"\"\n        if self.rms_phase_gain is None:\n            raise ValueError(\"RMS phase gain is not set.\")\n        phi = self.rng.normal(loc=0.0, scale=self.rms_phase_gain, size=num_stations)\n        # Reference station to have zero phase gain\n        ref_station = 0\n        phi[ref_station] = 0.0\n\n        station_phase_gains = np.exp(1j * phi)\n        return station_phase_gains\n\n    def _apply_noise(self, visibility_set: VisibilitySet) -&gt; VisibilitySet:\n        \"\"\"Apply only the noise corruption to the given visibilities.\"\"\"\n        if self.sigma is None:\n            raise ValueError(\"Sigma for noise is not set.\")\n        noise_real = self.rng.normal(scale=self.sigma, size=visibility_set.vis.shape)\n        noise_imag = self.rng.normal(scale=self.sigma, size=visibility_set.vis.shape)\n        noise = noise_real + 1j * noise_imag\n        visibility_set.vis += noise\n\n        return visibility_set\n</code></pre>"},{"location":"reference/#starbox.simulate.Corruptions.apply","title":"<code>apply(visibility_set)</code>","text":"<p>Apply the corruptions to the given visibilities.</p> Source code in <code>src/starbox/simulate/corruptions.py</code> <pre><code>def apply(self, visibility_set: VisibilitySet) -&gt; VisibilitySet:\n    \"\"\"Apply the corruptions to the given visibilities.\"\"\"\n    corrupted_visibility_set = VisibilitySet(\n        vis=np.copy(visibility_set.vis),\n        uvw_m=visibility_set.uvw_m,\n        station1=visibility_set.station1,\n        station2=visibility_set.station2,\n        times_mjd=visibility_set.times_mjd,\n        freqs_hz=visibility_set.freqs_hz,\n        weights=visibility_set.weights,\n    )\n    if self.rms_phase_gain is not None:\n        station_phase_gains = self._sample_station_phase_gains(\n            num_stations=visibility_set.num_stations\n        )\n        corrupted_visibility_set = self._apply_station_phase_gain(\n            corrupted_visibility_set, station_phase_gains\n        )\n\n    if self.sigma is not None:\n        corrupted_visibility_set = self._apply_noise(corrupted_visibility_set)\n\n    return corrupted_visibility_set\n</code></pre>"},{"location":"reference/#starbox.simulate.Observation","title":"<code>Observation</code>","text":"<p>Observation configuration and derived sampling grids.</p> Source code in <code>src/starbox/simulate/observation.py</code> <pre><code>class Observation:\n    \"\"\"Observation configuration and derived sampling grids.\"\"\"\n\n    def __init__(self, config: ObservationConfig):\n        self.config = config\n        self.channel_width = self.config.total_bandwidth / self.config.num_channels\n\n        self._get_times()\n        self._get_frequencies()\n\n    def _get_times(self) -&gt; None:\n        \"\"\"Return time samples for the observation.\"\"\"\n        if self.config.num_timesteps &gt; 1:\n            timestep = self.config.observation_length / (self.config.num_timesteps - 1)\n            self.times = np.array(\n                [\n                    self.config.start_time + i * timestep\n                    for i in range(self.config.num_timesteps)\n                ]\n            )\n        else:\n            self.times = np.array([self.config.start_time])\n\n    def _get_frequencies(self) -&gt; None:\n        \"\"\"Return frequency channels for the observation.\"\"\"\n        self.frequencies = np.array(\n            [\n                self.config.start_frequency + i * self.channel_width\n                for i in range(self.config.num_channels)\n            ]\n        )\n</code></pre>"},{"location":"reference/#starbox.simulate.SkyModel","title":"<code>SkyModel</code>","text":"<p>A class representing a sky model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>The name of the sky model.</p> <code>ra_deg</code> <p>Right ascension of sources in degrees.</p> <code>dec_deg</code> <p>Declination of sources in degrees.</p> <code>flux_jy</code> <p>Flux densities of sources in Jansky.</p> <code>config</code> <p>The SkyModelConfig used to generate this sky model.</p> Source code in <code>src/starbox/simulate/skymodel.py</code> <pre><code>class SkyModel:\n    \"\"\"A class representing a sky model.\n\n    Attributes:\n        name: The name of the sky model.\n        ra_deg: Right ascension of sources in degrees.\n        dec_deg: Declination of sources in degrees.\n        flux_jy: Flux densities of sources in Jansky.\n        config: The SkyModelConfig used to generate this sky model.\n    \"\"\"\n\n    def __init__(\n        self,\n        config: SkyModelConfig,\n        name: str = \"Sky Model\",\n    ):\n        self.name = name\n        self.config = config\n        self._generate_sources()\n\n    def _generate_sources(self):\n        \"\"\"Generate the sky model sources.\"\"\"\n        rng = np.random.default_rng(self.config.seed)\n        ra_centre, dec_centre = self.config.phase_centre_deg\n        half_fov_deg = self.config.fov_deg / 2.0\n\n        self.ra_deg = rng.uniform(\n            ra_centre - half_fov_deg, ra_centre + half_fov_deg, self.config.num_sources\n        )\n        self.dec_deg = rng.uniform(\n            dec_centre - half_fov_deg,\n            dec_centre + half_fov_deg,\n            self.config.num_sources,\n        )\n        self.flux_jy = rng.uniform(\n            0.0, self.config.max_flux_jy, self.config.num_sources\n        )\n\n    def as_arrays(self) -&gt; tuple[np.ndarray, np.ndarray, np.ndarray]:\n        return self.ra_deg, self.dec_deg, self.flux_jy\n\n    def equals(self, other: \"SkyModel\", atol: float = 0.0, rtol: float = 0.0) -&gt; bool:\n        \"\"\"Check equality with another SkyModel within a tolerance.\"\"\"\n        ra1, dec1, f1 = self.as_arrays()\n        ra2, dec2, f2 = other.as_arrays()\n\n        return (\n            np.allclose(ra1, ra2, atol=atol, rtol=rtol)\n            and np.allclose(dec1, dec2, atol=atol, rtol=rtol)\n            and np.allclose(f1, f2, atol=atol, rtol=rtol)\n        )\n</code></pre>"},{"location":"reference/#starbox.simulate.SkyModel.equals","title":"<code>equals(other, atol=0.0, rtol=0.0)</code>","text":"<p>Check equality with another SkyModel within a tolerance.</p> Source code in <code>src/starbox/simulate/skymodel.py</code> <pre><code>def equals(self, other: \"SkyModel\", atol: float = 0.0, rtol: float = 0.0) -&gt; bool:\n    \"\"\"Check equality with another SkyModel within a tolerance.\"\"\"\n    ra1, dec1, f1 = self.as_arrays()\n    ra2, dec2, f2 = other.as_arrays()\n\n    return (\n        np.allclose(ra1, ra2, atol=atol, rtol=rtol)\n        and np.allclose(dec1, dec2, atol=atol, rtol=rtol)\n        and np.allclose(f1, f2, atol=atol, rtol=rtol)\n    )\n</code></pre>"},{"location":"reference/#starbox.simulate.Telescope","title":"<code>Telescope</code>","text":"<p>A class representing a radio telescope array.</p> Source code in <code>src/starbox/simulate/telescope.py</code> <pre><code>class Telescope:\n    \"\"\"A class representing a radio telescope array.\"\"\"\n\n    def __init__(\n        self,\n        cfg: TelescopeConfig,\n        name: str = \"Telescope\",\n    ):\n        \"\"\"Initialize the Telescope.\n\n        Args:\n            cfg: TelescopeConfig instance containing configuration parameters.\n            name: Name of the telescope.\n        \"\"\"\n        self.name = name\n        self.config = cfg\n\n        self.rng = np.random.default_rng(self.config.seed)\n        self.station_positions = self._configure_array()\n        self.station_ids = np.array(\n            [f\"{self.name}_STN{idx:03d}\" for idx in range(self.config.num_stations)]\n        )\n\n    def _configure_array(self) -&gt; np.ndarray:\n        \"\"\"Configure an array of antennas.\n\n        Generates a numpy array of shape (num_stations, 3) representing antenna positions in x (north),\n        y (east), and z (up) arranged randomly within a circle of the telescope's diameter.\n        \"\"\"\n        angles = self._get_angles()\n        radii = self._get_radii()\n        x, y, z = _compute_coordinates(angles, radii)\n        return np.column_stack((x, y, z))\n\n    def _get_angles(self) -&gt; np.ndarray:\n        \"\"\"Generate random angles for antenna placement.\"\"\"\n        return self.rng.uniform(0, 2 * np.pi, self.config.num_stations)\n\n    def _get_radii(self) -&gt; np.ndarray:\n        \"\"\"Generate random radii for antenna placement within the telescope diameter.\"\"\"\n        radius = self.config.diameter / 2\n        return radius * np.sqrt(self.rng.uniform(0, 1, self.config.num_stations))\n</code></pre>"},{"location":"reference/#starbox.simulate.Telescope.__init__","title":"<code>__init__(cfg, name='Telescope')</code>","text":"<p>Initialize the Telescope.</p> <p>Parameters:</p> Name Type Description Default <code>cfg</code> <code>TelescopeConfig</code> <p>TelescopeConfig instance containing configuration parameters.</p> required <code>name</code> <code>str</code> <p>Name of the telescope.</p> <code>'Telescope'</code> Source code in <code>src/starbox/simulate/telescope.py</code> <pre><code>def __init__(\n    self,\n    cfg: TelescopeConfig,\n    name: str = \"Telescope\",\n):\n    \"\"\"Initialize the Telescope.\n\n    Args:\n        cfg: TelescopeConfig instance containing configuration parameters.\n        name: Name of the telescope.\n    \"\"\"\n    self.name = name\n    self.config = cfg\n\n    self.rng = np.random.default_rng(self.config.seed)\n    self.station_positions = self._configure_array()\n    self.station_ids = np.array(\n        [f\"{self.name}_STN{idx:03d}\" for idx in range(self.config.num_stations)]\n    )\n</code></pre>"},{"location":"reference/#starbox.viz","title":"<code>starbox.viz</code>","text":"<p>Visualization module.</p> <p>This module provides functions for plotting radio telescope array configurations, sky models, uv-coverage, calibration solutions and images.</p> <p>Functions:</p> Name Description <code>plot_telescope</code> <p>Plot the array configuration of a telescope.</p> <code>plot_sky_model</code> <p>Plot the sky model sources.</p> <code>plot_uv_coverage</code> <p>Plot the UV coverage given UVW coordinates.</p> <code>plot_gains</code> <p>Plot the calibration solutions.</p> <code>plot_image</code> <p>Plot the 2D image data.</p>"},{"location":"reference/#starbox.viz.plot_gains","title":"<code>plot_gains(solutions)</code>","text":"<p>Plot the calibration solutions.</p> Source code in <code>src/starbox/viz/plot.py</code> <pre><code>def plot_gains(solutions: Solutions) -&gt; Figure:\n    \"\"\"Plot the calibration solutions.\"\"\"\n\n    fig = px.imshow(\n        np.real(solutions.station_phase_gains[:, :, 0].T),\n        title=\"Gains\",\n        labels={\n            \"x\": \"time\",\n            \"y\": \"frequency\",\n        },\n        origin=\"lower\",\n    )\n    fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\n    return fig\n</code></pre>"},{"location":"reference/#starbox.viz.plot_image","title":"<code>plot_image(image, title='Imaged Sky')</code>","text":"<p>Plot the image.</p> Source code in <code>src/starbox/viz/plot.py</code> <pre><code>def plot_image(image: np.ndarray, title=\"Imaged Sky\") -&gt; Figure:\n    \"\"\"Plot the image.\"\"\"\n\n    fig = px.imshow(image, title=title, labels={\"x\": \"RA\", \"y\": \"Dec\"})\n    fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\n    return fig\n</code></pre>"},{"location":"reference/#starbox.viz.plot_sky_model","title":"<code>plot_sky_model(sky_model)</code>","text":"<p>Plot the sky model sources.</p> Source code in <code>src/starbox/viz/plot.py</code> <pre><code>def plot_sky_model(sky_model: SkyModel) -&gt; Figure:\n    \"\"\"Plot the sky model sources.\"\"\"\n    ras, decs, fluxes = sky_model.as_arrays()\n    fig = px.scatter(\n        x=ras,\n        y=decs,\n        size=fluxes,\n        title=\"Sky Model\",\n        labels={\"x\": \"Right Ascension (deg)\", \"y\": \"Declination (deg)\"},\n    )\n    fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\n    return fig\n</code></pre>"},{"location":"reference/#starbox.viz.plot_telescope","title":"<code>plot_telescope(telescope)</code>","text":"<p>Plot the array configuration given antenna coordinates.</p> Source code in <code>src/starbox/viz/plot.py</code> <pre><code>def plot_telescope(telescope: Telescope) -&gt; Figure:\n    \"\"\"Plot the array configuration given antenna coordinates.\"\"\"\n    fig = px.scatter(\n        x=telescope.station_positions[:, 0],\n        y=telescope.station_positions[:, 1],\n        title=f\"{telescope.name}\",\n    )\n    fig.update_layout(\n        xaxis_title=\"X (North) [m]\",\n        yaxis_title=\"Y (East) [m]\",\n        yaxis_scaleanchor=\"x\",\n        yaxis_scaleratio=1,\n    )\n    fig.update_traces(marker=dict(size=15, color=\"blue\", symbol=\"cross\"))\n\n    return fig\n</code></pre>"},{"location":"reference/#starbox.viz.plot_uv_coverage","title":"<code>plot_uv_coverage(uvw_coordinates, title='UV Coverage')</code>","text":"<p>Plot the UV coverage given UVW coordinates.</p> Source code in <code>src/starbox/viz/plot.py</code> <pre><code>def plot_uv_coverage(uvw_coordinates: np.ndarray, title: str = \"UV Coverage\") -&gt; Figure:\n    \"\"\"Plot the UV coverage given UVW coordinates.\"\"\"\n\n    u = uvw_coordinates[:, 0]\n    v = uvw_coordinates[:, 1]\n\n    fig = px.scatter(\n        x=u, y=v, title=title, labels={\"x\": \"U (wavelengths)\", \"y\": \"V (wavelengths)\"}\n    )\n    fig.update_yaxes(scaleanchor=\"x\", scaleratio=1)\n\n    return fig\n</code></pre>"},{"location":"reference/#starbox.visibility","title":"<code>starbox.visibility</code>","text":"<p>Data class for visibility set.</p>"},{"location":"reference/#starbox.visibility.VisibilitySet","title":"<code>VisibilitySet</code>  <code>dataclass</code>","text":"<p>A data class representing a set of visibilities.</p> <p>Attributes:</p> Name Type Description <code>vis</code> <code>ndarray</code> <p>Complex visibilities with shape (time, baseline, chan).</p> <code>uvw_m</code> <code>ndarray</code> <p>UVW coordinates in meters with shape (time, baseline, 3).</p> <code>station1</code> <code>ndarray</code> <p>Indices of the first station for each baseline.</p> <code>station2</code> <code>ndarray</code> <p>Indices of the second station for each baseline.</p> <code>times_mjd</code> <code>ndarray</code> <p>Times of the observations in Modified Julian Date.</p> <code>freqs_hz</code> <code>ndarray</code> <p>Frequencies of the channels in Hz.</p> <code>weights</code> <code>ndarray</code> <p>Weights for each visibility with shape (time, baseline, chan).</p> Source code in <code>src/starbox/visibility.py</code> <pre><code>@dataclass\nclass VisibilitySet:\n    \"\"\"A data class representing a set of visibilities.\n\n    Attributes:\n        vis: Complex visibilities with shape (time, baseline, chan).\n        uvw_m: UVW coordinates in meters with shape (time, baseline, 3).\n        station1: Indices of the first station for each baseline.\n        station2: Indices of the second station for each baseline.\n        times_mjd: Times of the observations in Modified Julian Date.\n        freqs_hz: Frequencies of the channels in Hz.\n        weights: Weights for each visibility with shape (time, baseline, chan).\n    \"\"\"\n\n    vis: np.ndarray  # (time, baseline, chan)\n    uvw_m: np.ndarray  # (time, baseline, 3)\n    station1: np.ndarray  # (baseline,)\n    station2: np.ndarray  # (baseline,)\n    times_mjd: np.ndarray  # (time,)\n    freqs_hz: np.ndarray  # (chan,)\n    weights: np.ndarray  # (time, baseline, chan)\n\n    @property\n    def station_ids(self) -&gt; np.ndarray:\n        \"\"\"Get the unique station IDs from the baseline indices.\"\"\"\n        unique_stations = np.unique(np.concatenate((self.station1, self.station2)))\n        return unique_stations\n\n    @property\n    def num_stations(self) -&gt; int:\n        \"\"\"Get the number of unique stations in the visibility set.\"\"\"\n        return len(self.station_ids)\n</code></pre>"},{"location":"reference/#starbox.visibility.VisibilitySet.num_stations","title":"<code>num_stations</code>  <code>property</code>","text":"<p>Get the number of unique stations in the visibility set.</p>"},{"location":"reference/#starbox.visibility.VisibilitySet.station_ids","title":"<code>station_ids</code>  <code>property</code>","text":"<p>Get the unique station IDs from the baseline indices.</p>"},{"location":"tutorials/","title":"Tutorials","text":""}]}